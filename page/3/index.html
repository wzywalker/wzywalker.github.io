<!DOCTYPE HTML>
<html lang="english">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Maverick,AlanDecode,Galileo,blog" />
    <meta name="generator" content="Maverick 1.2.1" />
    <meta name="template" content="Prism" />
    <link rel="alternate" type="application/rss+xml" title="walker's code blog &raquo; RSS 2.0" href="/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="walker's code blog &raquo; ATOM 1.0" href="/feed/atom/index.xml" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-b9d78ff38a.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-182e5a8869.css">
    <link href="https://fonts.googleapis.com/css?family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <script>
        var ExSearchConfig = {
            root: "",
            api: "https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/8efbf32b97eb687e2e3849753352fafd.json"
        }

    </script>
    
<title>walker's code blog</title>
<meta name="author" content="AlanDecode" />
<meta name="description" content="coder, reader" />
<meta property="og:title" content="walker's code blog" />
<meta property="og:description" content="coder, reader" />
<meta property="og:site_name" content="walker's code blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/page/3/" />
<meta property="og:image" content="walker's code blog" />
<meta name="twitter:title" content="walker's code blog" />
<meta name="twitter:description" content="coder, reader" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/android-chrome-512x512.png" />


    
</head>

<body>
    <div class="container prism-container">
        <header class="prism-header" id="prism__header">
            <h1 class="text-uppercase brand"><a class="no-link" href="/" target="_self">walker's code blog</a></h1>
            <p>coder, reader</p>
            <nav class="prism-nav"><ul><li><a class="no-link text-uppercase " href="/" target="_self">Home</a></li><li><a class="no-link text-uppercase " href="/archives/" target="_self">Archives</a></li><li><a class="no-link text-uppercase " href="/about/" target="_self">About</a></li><li><a href="#" target="_self" class="search-form-input no-link text-uppercase">Search</a></li></ul></nav>
        </header>
        <div class="prism-wrapper" id="prism__wrapper">
            
<main>    
    

<section id="prism__post-list" class="prism-section row">
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B6%5D_Persistence/" target="_self">cs193p_2021笔记[6]_Persistence</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B6%5D_Persistence/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Persistence</h1>
<p>持久化数据的方式有</p><ul>
<li>File system（FileManager）</li>
<li>Sqlite/CoreData</li>
<li>iCloud: 根据上面两种格式存储</li>
<li>CloutKit: a database in the cloud (network)</li>
<li>UserDefaults</li>
<li>Codable/JSON</li>
<li>UIDocument (UIKit feature)(与Files App集成)</li>
<li>3rd-party</li>
</ul>
<h2>UserDefaults</h2>
<ul>
<li>只能存储<code>Property List</code></li>
<li><code>Property List</code>支持String, Int, Bool, floating point, Date, Data, Array or Dictionary<ul>
<li>任何其它类型需要转成<code>Property List</code></li>
<li><code>Codable</code> converts structs into <code>Data</code> objects (and <code>Data</code> is a <code>Property List</code>).</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">defaults</span> <span class="p">=</span> <span class="n">UserDefaults</span><span class="p">.</span><span class="n">standard</span>
<span class="n">defaults</span><span class="p">.</span><span class="kr">set</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">SomeKey</span><span class="err">”</span><span class="p">)</span> <span class="c1">// object must be a Property List</span>
<span class="n">defaults</span><span class="p">.</span><span class="n">setDouble</span><span class="p">(</span><span class="mf">37.5</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyDouble</span><span class="err">”</span><span class="p">)</span>

<span class="c1">// retrive</span>

<span class="kd">let</span> <span class="nv">i</span><span class="p">:</span> <span class="nb">Int</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">integer</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyInteger</span><span class="err">”</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">b</span><span class="p">:</span> <span class="n">Data</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyData</span><span class="err">”</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">u</span><span class="p">:</span> <span class="n">URL</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">url</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyURL</span><span class="err">”</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">strings</span><span class="p">:</span> <span class="p">[</span><span class="nb">String</span><span class="p">]</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">stringArray</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyString</span><span class="err">”</span><span class="p">)</span> 
<span class="c1">// etc.</span>
<span class="c1">// Retrieving Arrays of anything but String is more complicated ...</span>
<span class="kd">let</span> <span class="nv">a</span> <span class="p">=</span> <span class="n">defaults</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">forKey</span><span class="p">:</span> <span class="err">“</span><span class="n">MyArray</span><span class="err">”</span><span class="p">)</span> <span class="c1">// will return Array&lt;Any&gt;</span>
<span class="c1">// 最好用Codable的data(forKey:)替代</span>
</pre></div>
<h2>Core Data</h2>
<p>SwiftUI进行的集成:</p><ul>
<li>创建的对象是<code>ObservableObjects</code></li>
<li>一个property wrapper <code>@FetchRequest</code></li>
<li>管理对象(context)是<code>NSManagedObjectContext</code></li>
<li>context通过<code>@Environment</code>传入</li>
</ul>
<p>demo:</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">Environnment</span><span class="p">(</span><span class="err">\</span><span class="p">.</span><span class="n">managedObjectContext</span><span class="p">)</span> <span class="kd">var</span> <span class="nv">context</span>
<span class="kd">let</span> <span class="nv">flight</span> <span class="p">=</span> <span class="n">Flight</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
<span class="n">flight</span><span class="p">.</span><span class="n">aircraft</span> <span class="p">=</span> <span class="err">“</span><span class="n">B737</span><span class="err">”</span> <span class="c1">// etc.</span>

<span class="kd">let</span> <span class="nv">ksjc</span> <span class="p">=</span> <span class="n">Airport</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">context</span><span class="p">)</span>
<span class="n">ksjc</span><span class="p">.</span><span class="n">icao</span> <span class="p">=</span> <span class="err">“</span><span class="n">KSJC</span><span class="err">”</span> <span class="c1">// etc.</span>

<span class="n">flight</span><span class="p">.</span><span class="n">origin</span> <span class="p">=</span> <span class="n">ksjc</span> <span class="c1">// this would add flight to ksjc.flightsFrom too try? context.save()</span>

<span class="kd">let</span> <span class="nv">request</span> <span class="p">=</span> <span class="bp">NSFetchRequest</span><span class="p">&lt;</span><span class="n">Flight</span><span class="p">&gt;(</span><span class="n">entityName</span><span class="p">:</span> <span class="err">“</span><span class="n">Flight</span><span class="err">”</span><span class="p">)</span> <span class="n">request</span><span class="p">.</span><span class="n">predicate</span> <span class="p">=</span>
<span class="bp">NSPredicate</span><span class="p">(</span><span class="n">format</span><span class="p">:</span> <span class="err">“</span><span class="n">arrival</span> <span class="o">&lt;</span> <span class="o">%</span><span class="p">@</span> <span class="n">and</span> <span class="n">origin</span> <span class="p">=</span> <span class="o">%</span><span class="p">@</span><span class="err">“</span><span class="p">,</span> <span class="n">Date</span><span class="p">(),</span> <span class="n">ksjc</span><span class="p">)</span> 
<span class="n">request</span><span class="p">.</span><span class="n">sortDescriptors</span> <span class="p">=</span> <span class="p">[</span><span class="bp">NSSortDescriptor</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="err">“</span><span class="n">ident</span><span class="err">”</span><span class="p">,</span> <span class="n">ascending</span><span class="p">:</span> <span class="kc">true</span><span class="p">)]</span> 

<span class="kd">let</span> <span class="nv">flights</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">context</span><span class="p">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">request</span><span class="p">)</span> <span class="c1">// past KSJC flights sorted by ident</span>
<span class="c1">// flights is nil if fetch failed, [] if no such flights, otherwise [Flight]</span>
</pre></div>
<p>以上是core data部分，还是浓浓的OC的痕迹，看看Swift UI的版本。</p><p>首先，上述的<code>Flights, Airports</code>都是ViewModel。它自然拥有它的<code>Property Wrapper</code>:</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">FetchRequest</span><span class="p">(</span><span class="n">entity</span><span class="p">:</span><span class="n">sortDescriptors</span><span class="p">:</span><span class="n">predicate</span><span class="p">:)</span> <span class="kd">var</span> <span class="nv">flights</span><span class="p">:</span> <span class="n">FetchedResults</span><span class="p">&lt;</span><span class="n">Flight</span><span class="p">&gt;</span>
<span class="p">@</span><span class="n">FetchRequest</span><span class="p">(</span><span class="n">fetchRequest</span><span class="p">:)</span> <span class="kd">var</span> <span class="nv">airports</span><span class="p">:</span> <span class="n">FetchedResults</span><span class="p">&lt;</span><span class="n">Airport</span><span class="p">&gt;</span>

<span class="c1">// flights and airports will continuously update as the database changes. </span>
<span class="n">ForEach</span><span class="p">(</span><span class="n">flights</span><span class="p">)</span> <span class="p">{</span> <span class="n">flight</span> <span class="k">in</span>
    <span class="c1">// UI for a flight built using flight </span>
<span class="p">}</span>

<span class="c1">// bi-binding</span>
<span class="n">_flights</span> <span class="p">=</span> <span class="n">FetchRequest</span><span class="p">(...)</span>
</pre></div>
<h2>Cloud Kit</h2>
<p>上个demo吧</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">db</span> <span class="p">=</span> <span class="bp">CKContainer</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="kd">public</span><span class="o">/</span><span class="n">shared</span><span class="o">/</span><span class="n">privateCloudDatabase</span> 
<span class="c1">// Record理解为Table</span>
<span class="kd">let</span> <span class="nv">tweet</span> <span class="p">=</span> <span class="bp">CKRecord</span><span class="p">(</span><span class="err">“</span><span class="n">Tweet</span><span class="err">”</span><span class="p">)</span>
<span class="c1">// 索引理解为Field</span>
<span class="n">tweet</span><span class="p">[</span><span class="err">“</span><span class="n">text</span><span class="err">”</span><span class="p">]</span> <span class="p">=</span> <span class="err">“</span><span class="mi">140</span> <span class="n">characters</span> <span class="n">of</span> <span class="n">pure</span> <span class="n">joy</span><span class="err">”</span>
<span class="kd">let</span> <span class="nv">tweeter</span> <span class="p">=</span> <span class="bp">CKRecord</span><span class="p">(</span><span class="err">“</span><span class="n">TwitterUser</span><span class="err">”</span><span class="p">)</span>
<span class="n">tweet</span><span class="p">[</span><span class="err">“</span><span class="n">tweeter</span><span class="err">”</span><span class="p">]</span> <span class="p">=</span> <span class="bp">CKReference</span><span class="p">(</span><span class="n">record</span><span class="p">:</span> <span class="n">tweeter</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="p">.</span><span class="n">deleteSelf</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="n">tweet</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">savedRecord</span><span class="p">:</span> <span class="bp">CKRecord</span><span class="p">?,</span> <span class="n">error</span><span class="p">:</span> <span class="bp">NSError</span><span class="p">?)</span> <span class="p">-&gt;</span> <span class="nb">Void</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">error</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="c1">// hooray!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">error</span><span class="p">?.</span><span class="n">errorCode</span> <span class="p">==</span> <span class="n">CKErrorCode</span><span class="p">.</span> <span class="n">NotAuthenticated</span><span class="p">.</span><span class="n">rawValue</span> <span class="p">{</span>
        <span class="c1">// tell user he or she has to be logged in to iCloud for this to work!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// report other errors (there are 29 different CKErrorCodes!) </span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Query</span>
<span class="c1">// 类似core data, 构造predict, request(就是query)即可</span>

<span class="kd">let</span> <span class="nv">predicate</span> <span class="p">=</span> <span class="bp">NSPredicate</span><span class="p">(</span><span class="n">format</span><span class="p">:</span> <span class="err">“</span><span class="n">text</span> <span class="bp">contains</span> <span class="o">%</span><span class="p">@</span><span class="err">“</span><span class="p">,</span> <span class="n">searchString</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">query</span> <span class="p">=</span> <span class="bp">CKQuery</span><span class="p">(</span><span class="n">recordType</span><span class="p">:</span> <span class="err">“</span><span class="n">Tweet</span><span class="err">”</span><span class="p">,</span> <span class="n">predicate</span><span class="p">:</span> <span class="n">predicate</span><span class="p">)</span>
<span class="n">db</span><span class="p">.</span><span class="n">perform</span><span class="p">(</span><span class="n">query</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="n">records</span><span class="p">:</span> <span class="p">[</span><span class="bp">CKRecord</span><span class="p">]?,</span> <span class="n">error</span><span class="p">:</span> <span class="bp">NSError</span><span class="p">?)</span> <span class="k">in</span>
    <span class="k">if</span> <span class="n">error</span> <span class="p">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// records will be an array of matching CKRecords</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">error</span><span class="p">?.</span><span class="n">errorCode</span> <span class="p">==</span> <span class="n">CKErrorCode</span><span class="p">.</span><span class="n">NotAuthenticated</span><span class="p">.</span><span class="n">rawValue</span> <span class="p">{</span>
        <span class="c1">// tell user he or she has to be logged in to iCloud for this to work!</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// report other errors (there are 29 different CKErrorCodes!) </span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>One of the coolest features of Cloud Kit is its ability to <code>send push notifications</code> on changes. All you do is register an <code>NSPredicate</code> and whenever the database changes to match it,</p><h2>File System</h2>
<p>Sandbox包含：</p><ul>
<li>Application directory — Your executable, .jpgs, etc.; not writeable.</li>
<li>Documents directory — Permanent storage created by and always visible to the user.</li>
<li>Application Support directory — Permanent storage not seen directly by the user.</li>
<li>Caches directory — Store temporary files here (this is not backed up).</li>
<li>Other directories (see documentation)</li>
<li>...</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">url</span><span class="p">:</span> <span class="n">URL</span> <span class="p">=</span> <span class="n">FileManager</span><span class="p">.</span><span class="k">default</span><span class="p">.</span><span class="n">url</span><span class="p">(</span>
    <span class="k">for</span> <span class="n">directory</span><span class="p">:</span> <span class="n">FileManager</span><span class="p">.</span><span class="n">SearchPathDirectory</span><span class="p">.</span><span class="n">documentDirectory</span><span class="p">,</span> <span class="c1">// for example </span>
    <span class="k">in</span> <span class="n">domainMask</span><span class="p">:</span> <span class="p">.</span><span class="n">userDomainMask</span> <span class="c1">// always .userDomainMask on iOS</span>
    <span class="n">appropriateFor</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="c1">// only meaningful for “replace” file operations</span>
    <span class="n">create</span><span class="p">:</span> <span class="kc">true</span> <span class="c1">// whether to create the system directory if it doesn’t already exist</span>
 <span class="p">)</span>
</pre></div>
<p>Examples of SearchPathDirectory values :</p><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">documentDirectory</span><span class="p">,</span> 
<span class="p">.</span><span class="n">applicationSupportDirectory</span><span class="p">,</span> 
<span class="p">.</span><span class="n">cachesDirectory</span><span class="p">,</span> 
<span class="n">etc</span><span class="p">.</span>
</pre></div>
<p>再列些常用api：</p><div class="highlight"><pre><span></span><span class="c1">// URL</span>

<span class="kd">func</span> <span class="nf">appendingPathComponent</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">URL</span>
<span class="kd">func</span> <span class="nf">appendingPathExtension</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">URL</span> <span class="c1">// e.g. “jpg”</span>
<span class="kd">var</span> <span class="nv">isFileURL</span><span class="p">:</span> <span class="nb">Bool</span> <span class="c1">// is this a file URL (whether file exists or not) or something else? </span>
<span class="kd">func</span> <span class="nf">resourceValues</span><span class="p">(</span><span class="k">for</span> <span class="n">keys</span><span class="p">:</span> <span class="p">[</span><span class="n">URLResourceKey</span><span class="p">])</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="p">[</span><span class="n">URLResourceKey</span><span class="p">:</span><span class="nb">Any</span><span class="p">]?</span> 
<span class="c1">// Example keys: .creationDateKey, .isDirectoryKey, .fileSizeKey</span>

<span class="c1">// Data</span>

<span class="c1">// retrive binary data</span>
<span class="c1">// option almost always []</span>
<span class="kd">init</span><span class="p">(</span><span class="n">contentsOf</span><span class="p">:</span> <span class="n">URL</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">Data</span><span class="p">.</span><span class="n">ReadingOptions</span><span class="p">)</span> <span class="kr">throws</span> 
<span class="c1">// write</span>
<span class="c1">// The options can be things like .atomic (write to tmp file, then swap) or .withoutOverwriting.</span>
<span class="kd">func</span> <span class="nf">write</span><span class="p">(</span><span class="n">to</span> <span class="n">url</span><span class="p">:</span> <span class="n">URL</span><span class="p">,</span> <span class="n">options</span><span class="p">:</span> <span class="n">Data</span><span class="p">.</span><span class="n">WritingOptions</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">-&gt;</span> <span class="nb">Bool</span>

<span class="c1">// FileManager</span>
<span class="n">fileExists</span><span class="p">(</span><span class="n">atPath</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span>
<span class="c1">// Can also create and enumerate directories; move, copy, delete files; etc.</span>
</pre></div>
<h2>Codable</h2>
<ul>
<li>保留一个对象所有的var（变量）的机制</li>
<li>如果一个Struct它的成员变是Codable的，那么Swift会帮你把这个Struct实现Codable，比如没有associated data的Enum。</li>
<li>帮你实现不代表不要显式声明</li>
<li>基础类型基本上都实现了Codable</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">object</span><span class="p">:</span> <span class="n">MyType</span> <span class="p">=</span> <span class="p">...</span>
<span class="c1">// encode</span>
<span class="kd">let</span> <span class="nv">jsonData</span><span class="p">:</span> <span class="n">Data</span><span class="p">?</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONEncoder</span><span class="p">().</span><span class="n">encode</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>

<span class="c1">// write file</span>
<span class="k">try</span> <span class="n">jsonData</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">url</span><span class="p">)</span>

<span class="c1">// deocde as string</span>
<span class="kd">let</span> <span class="nv">jsonString</span> <span class="p">=</span> <span class="nb">String</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">jsonData</span><span class="p">!,</span> <span class="n">encoding</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span>

<span class="c1">// decode as object</span>
<span class="kd">let</span> <span class="nv">myObject</span><span class="p">:</span> <span class="n">MyType</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">MyType</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">jsonData</span><span class="p">!)</span>
<span class="c1">// 从字符串到对象没有一步到位的办法，只能先string-&gt;Data</span>
<span class="kd">let</span> <span class="nv">data</span> <span class="p">=</span> <span class="n">jsstring</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">using</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span> <span class="c1">// 再把data传到上术方法里</span>
</pre></div>
<p>encode, decode是会throw的，注意try_catch相应的Error，比如<code>.keyNotFound, .dataCorrupted...</code></p><h3>CodingKeys</h3>
<p>json与对象相互进行转化有一个通用的需求，就是键的映射，这更常用在外部API与本地类的映射中，比如userId，别人叫guestId，等等，Swift中，用一个叫<code>CodingKeys</code>的枚举来实现这个映射：</p><div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kd">enum</span> <span class="nc">CodingKeys</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">CodingKey</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">uid</span> <span class="p">=</span> <span class="s">&quot;user_id&quot;</span>
    <span class="k">case</span> <span class="n">someDate</span> <span class="p">=</span> <span class="s">&quot;some_date&quot;</span>
    <span class="k">case</span> <span class="n">pname</span> <span class="p">=</span> <span class="s">&quot;panme&quot;</span> <span class="c1">// 表示在JSON中也叫这个名字 </span>
    <span class="k">case</span> <span class="n">sku</span> <span class="c1">// 如果名字一样的话，可以这么简写 </span>
    <span class="c1">// 但是不写的话，序列化的时候就不会序列这个字段了</span>
    <span class="c1">// 解码时会有 KeyNotFound 类的错误</span>
<span class="p">}</span>

<span class="c1">// 结合起来，用在init中</span>
<span class="kd">init</span><span class="p">(</span><span class="n">from</span> <span class="n">decoder</span><span class="p">:</span> <span class="n">Decoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
    <span class="c1">// container是切入点，要弄清楚</span>
    <span class="c1">// 如果没有手写键的映射表，那么keydBy就是自己</span>
    <span class="kd">let</span> <span class="nv">container</span> <span class="p">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">CodingKeys</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
    <span class="n">someDate</span> <span class="p">=</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">Date</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">someDate</span><span class="p">)</span> 
    <span class="c1">// 从json中加载.someDate对应的键的值，尝试解码成Date</span>
    <span class="c1">// other vars (每种case必须全部都有)</span>
<span class="p">}</span>
</pre></div>
<h3>Enum</h3>
<p>序列化枚举有点复杂：</p><ol>
<li>简单枚举应该怎么序列化？ 其实是序列化成case对应的名字和表示空JSON的<code>{}</code>组成的键值对，比如<code>{&quot;math&quot;:{}}</code></li>
<li>有关联数据的枚举呢？ 那就得自己提供<code>encoder</code>:<ul>
<li><code>case url: try container.encode(url, forKey: .url)</code> 即对相应的枚举值进行相应的encode</li>
</ul>
</li>
<li>并且自行decode，但是与struct（为每一个key填值）不同，因为枚举变量只是一个值，所以是依次尝试，解码成功就认定是那一个枚举值</li>
</ol>
<div class="highlight"><pre><span></span><span class="k">if</span> <span class="kd">let</span> <span class="nv">url</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="n">URL</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">...</span> <span class="c1">// 别的尝试</span>

<span class="c1">// 此句的作用是根据.url对应的键名，取出值，反射成URL对象，如果成功，那么这个枚举值是.url无疑</span>
<span class="c1">// 而且关联数据就是反射的结果</span>
<span class="c1">// 如果失败，继续换一个键名，将对应的值转成对应的类型，依次类推</span>
</pre></div>
<ol start="4">
<li>那么如何手动decode一个原始的枚举呢？<ul>
<li>我们知道上述实践是为了反射出关联数据，并且根据能够成功反射关联数据来判断枚举类型</li>
<li>原始枚举需要encode哪个值呢？-&gt; 目前我只能做一个空<code>struct</code>来实现序列化成<code>{}</code>的目的 -&gt; 为了跟默认形态保持一致<ul>
<li>事实上你是可以encode成任意值的（比如100，&quot;hello&quot;，因为我们只关心有没有这个键，有的话，就是这个枚举类型，只是<code>{}</code>拥有可读性</li>
<li>你encode成什么值，decode的时候对对应的键尝试去反射回这个值就行了</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>最后，思考题：</p><blockquote>
<p>上面说了，原生枚举序列化成： <code>{&quot;math&quot;:{}}</code>，也说了，如果，键对应的值对原生枚举序列化是没意义的，可以是任何值，那么对于<code>{&quot;math&quot;:100}</code>，能否顺序序列化回其枚举形态<code>.math</code>呢？</p></blockquote>
<p>答案：</p><ol>
<li>值为100报错了</li>
<li>于是我改为&quot;&quot;或&quot;other“等字符串或空字符串，解码的结果是<code>nil</code></li>
</ol>
<p>也就是说，默认的decode只认<code>{}</code></p><figure  style="flex: 82.77310924369748" ><img width="1182" height="714" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/c3a4240a7582937166f9300c35b4e868.png" alt=""/></figure><p>而前面我们知道了，如果是自己手写，它可以是任何值，它的意义仅仅是个标识，并不会取它的值。验证：</p><div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">NormEnum</span><span class="p">:</span> <span class="n">Codable</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">history</span><span class="p">,</span> <span class="n">math</span><span class="p">,</span> <span class="n">geometry</span>

    <span class="kd">private</span> <span class="kd">enum</span> <span class="nc">keyMap</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">CodingKey</span><span class="p">{</span>
        <span class="k">case</span> <span class="n">history</span>  <span class="p">=</span> <span class="s">&quot;HIST&quot;</span>
        <span class="k">case</span> <span class="n">math</span>     <span class="p">=</span> <span class="s">&quot;MATH&quot;</span>
        <span class="k">case</span> <span class="n">geometry</span> <span class="p">=</span> <span class="s">&quot;GEOM&quot;</span>
    <span class="p">}</span>

    <span class="kd">func</span> <span class="nf">encode</span><span class="p">(</span><span class="n">to</span> <span class="n">encoder</span><span class="p">:</span> <span class="n">Encoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nv">container</span> <span class="p">=</span> <span class="k">try</span> <span class="n">encoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">keyMap</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
        <span class="k">switch</span> <span class="kc">self</span><span class="p">{</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">history</span><span class="p">:</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">history</span><span class="p">)</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">math</span><span class="p">:</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">math</span><span class="p">)</span>
        <span class="k">case</span> <span class="p">.</span><span class="n">geometry</span><span class="p">:</span> <span class="k">try</span> <span class="n">container</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">geometry</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">init</span><span class="p">(</span><span class="n">from</span> <span class="n">decoder</span><span class="p">:</span> <span class="n">Decoder</span><span class="p">)</span> <span class="kr">throws</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nv">container</span> <span class="p">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="p">.</span><span class="n">container</span><span class="p">(</span><span class="n">keyedBy</span><span class="p">:</span> <span class="n">keyMap</span><span class="p">.</span><span class="kc">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">s</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">String</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">history</span><span class="p">)</span> <span class="p">{</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">history</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="kd">let</span> <span class="nv">s</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">container</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="nb">String</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">forKey</span><span class="p">:</span> <span class="p">.</span><span class="n">math</span><span class="p">)</span> <span class="p">{</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">math</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kc">self</span> <span class="p">=</span> <span class="p">.</span><span class="n">geometry</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>上面的代码中，我将三个字段全部用空字符串编码，并且给了三个不同的键名，现在，我真入任意值，比如<code>&quot;HAHA&quot;</code>，解码看看：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">js2</span> <span class="p">=</span> <span class="s">&quot;{</span><span class="se">\&quot;</span><span class="s">MATH</span><span class="se">\&quot;</span><span class="s">:</span><span class="se">\&quot;</span><span class="s">HAHA</span><span class="se">\&quot;</span><span class="s">}&quot;</span>
<span class="kd">let</span> <span class="nv">js2d</span> <span class="p">=</span> <span class="n">js2</span><span class="p">.</span><span class="n">data</span><span class="p">(</span><span class="n">using</span><span class="p">:</span> <span class="p">.</span><span class="n">utf8</span><span class="p">)</span>
<span class="kd">let</span> <span class="nv">myobj2</span> <span class="p">=</span> <span class="k">try</span><span class="p">?</span> <span class="n">JSONDecoder</span><span class="p">().</span><span class="n">decode</span><span class="p">(</span><span class="n">NormEnum</span><span class="p">.</span><span class="kc">self</span><span class="p">,</span> <span class="n">from</span><span class="p">:</span> <span class="n">js2d</span><span class="p">!)</span>
</pre></div>
<p>结果成功认出myobj2是一个<code>.math</code>。原理当然是我的代码里在尝试转成一个字符串，而没有限定是什么字符串。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B6%5D_Persistence/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B5%5D_Property-Wrapper/" target="_self">cs193p_2021笔记[5]_Property-Wrapper</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B5%5D_Property-Wrapper/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Property Wrappers</h1>
<p>C#中的<code>Attributes</code>，python中的<code>Decorators</code>, Java的<code>Annonations</code>，类似的设计模式。</p><ul>
<li>A property wrapper is actually a <code>struct</code>.</li>
<li>这个特殊的<code>struct</code>封装了一些模板行为应用到它们wrap的vars上：<ol>
<li>Making a var live in the heap (<code>@State</code>)</li>
<li>Making a var publish its changes (<code>@Published</code>)</li>
<li>Causing a View to redraw when a published change is detected (<code>@ObservedObject</code>)</li>
</ol>
</li>
</ul>
<p>即能够分配到堆上，能够通知状态变化和能重绘等，可以理解为<code>语法糖</code>。</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">Published</span> <span class="kd">var</span> <span class="nv">emojiArt</span><span class="p">:</span> <span class="n">EmojiArt</span> <span class="p">=</span> <span class="n">EmojiArt</span><span class="p">()</span>

<span class="c1">// ... is really just this struct ...</span>
<span class="kd">struct</span> <span class="nc">Published</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="n">EmojiArt</span>
    <span class="kd">var</span> <span class="nv">projectedValue</span><span class="p">:</span> <span class="n">Publisher</span><span class="p">&lt;</span><span class="n">EmojiArt</span><span class="p">,</span> <span class="n">Never</span><span class="p">&gt;</span>  <span class="c1">// i.e. $</span>
<span class="p">}</span>

<span class="c1">// `projected value`的类型取决于wrapper自己，比如本例就是一个`Publisher`</span>

<span class="c1">// 我理解为一个属性和一个广播器</span>

<span class="c1">// ... and Swift (approximately) makes these vars available to you ...</span>
<span class="kd">var</span> <span class="nv">_emojiArt</span><span class="p">:</span> <span class="n">Published</span> <span class="p">=</span> <span class="n">Published</span><span class="p">(</span><span class="n">wrappedValue</span><span class="p">:</span> <span class="n">EmojiArt</span><span class="p">())</span> 
<span class="kd">var</span> <span class="nv">emojiArt</span><span class="p">:</span> <span class="n">EmojiArt</span> <span class="p">{</span>
     <span class="kr">get</span> <span class="p">{</span> <span class="n">_emojiArt</span><span class="p">.</span><span class="n">wrappedValue</span> <span class="p">}</span>
     <span class="kr">set</span> <span class="p">{</span> <span class="n">_emojiArt</span><span class="p">.</span><span class="n">wrappedValue</span> <span class="p">=</span> <span class="n">newValue</span> <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
<p>把get,set直接通过<code>$emojiArt</code>(即projectedValue)来使用</p><p>当一个<code>Published</code>值发生变化：</p><ul>
<li>It publishes the change through its <em>projectedValue</em> (<code>$emojiArt</code>) which is a <code>Publisher</code>.</li>
<li>It also invokes <code>objectWillChange.send()</code> in its enclosing <code>ObservableObject</code>.</li>
</ul>
<p>下面列的几种<code>Property wrapper</code>，我们主要关心最核心的两个概念，<code>wrappedValue</code>和<code>projectedValue</code>是什么就行了:</p><h2>@State</h2>
<p>这是第二次提到了，在<code>Property Observers</code>一节里预告过，基本上点<code>@</code>的，大都为<code>Property Wrapper</code>的内容。</p><ul>
<li>The wrappedValue is: <code>anything</code> (but almost certainly a value type).</li>
<li>What it does:<ul>
<li>stores the wrappedValue in the heap;</li>
<li>when it changes, <code>invalidates</code> the <code>View</code>.</li>
</ul>
</li>
<li>Projected value (i.e. $): a <code>Binding</code> (to that <em>value in the heap</em>).</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">@</span><span class="n">State</span> <span class="kd">private</span> <span class="kd">var</span> <span class="nv">foo</span><span class="p">:</span> <span class="nb">Int</span>
<span class="kd">init</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">_foo</span> <span class="p">=</span> <span class="p">.</span><span class="kd">init</span><span class="p">(</span><span class="n">initiaValue</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
<p>注意<code>_</code>和<code>$</code>的区别。</p><h2>@StateObject &amp; @ObservedObject</h2>
<ul>
<li>The wrappedValue is: <code>anything</code> that implements the <code>ObservableObject</code> protocol (ViewModels).</li>
<li>What it does:<ul>
<li><code>invalidates</code> the <code>View</code> when wrappedValue does <em>objectWillChange.send()</em>.</li>
</ul>
</li>
<li>Projected value (i.e. $): a <code>Binding</code> (to the vars of the wrappedValue (a <em>ViewModel</em>)).</li>
</ul>
<blockquote>
<p><strong>@StateObject V.S. @State</strong></p></blockquote>
<ul>
<li>一个类型是<code>ObservableObject</code>s， 一个是value type</li>
</ul>
<blockquote>
<p><strong>@StateObject V.S. @ObservedObject</strong></p></blockquote>
<ul>
<li>@StateObject is a &quot;source of truth&quot;，也就是说可以直接赋值：<code>@StateObject var foo = SomeObservableObject()</code></li>
<li>能用在<em>View, APP, Scene</em>等场景</li>
<li>如果用在View里，生命周期与View一致</li>
</ul>
<div class="highlight"><pre><span></span><span class="p">@</span><span class="n">main</span>
<span class="kd">struct</span> <span class="nc">EmojiArtApp</span><span class="p">:</span> <span class="n">App</span> <span class="p">{</span>
    <span class="c1">// stateObject, source of truth</span>
    <span class="c1">// defined in the app</span>
    <span class="p">@</span><span class="n">StateObject</span> <span class="kd">var</span> <span class="nv">paletteStore</span> <span class="p">=</span> <span class="n">PaletteStore</span><span class="p">(</span><span class="n">named</span><span class="p">:</span> <span class="s">&quot;default&quot;</span><span class="p">)</span>

    <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="n">Scene</span> <span class="p">{</span>
    <span class="n">DocumentGroup</span><span class="p">(</span><span class="n">newDocument</span><span class="p">:</span> <span class="p">{</span> <span class="n">EmojiArtDocument</span><span class="p">()</span> <span class="p">})</span> <span class="p">{</span> <span class="n">config</span> <span class="k">in</span>
        <span class="n">EmojiArtDocumentView</span><span class="p">(</span><span class="n">document</span><span class="p">:</span> <span class="n">config</span><span class="p">.</span><span class="n">document</span><span class="p">)</span>
            <span class="p">.</span><span class="n">environmentObject</span><span class="p">(</span><span class="n">paletteStore</span><span class="p">)</span>  <span class="c1">// passed by environment</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>@Binding</h2>
<ul>
<li>The wrappedValue is: <code>a value</code> that is bound to something else.</li>
<li>What it does:<ul>
<li>gets/sets the value of the wrappedValue from <code>some other source</code>.</li>
<li>when the bound-to value changes, it <code>invalidates</code> the <code>View</code>.</li>
<li>Form表单典型应用场景，有UI变化的控件</li>
<li>手势过程中的State, 或drag时是否targted</li>
<li>模态窗口的状态</li>
<li>分割view后共享状态</li>
<li>总之，数据源只有一个(source of the truth)的场景，就不需要用两个@State而用@Binding,</li>
</ul>
</li>
<li>Projected value (i.e. $): a Binding (self; i.e. the Binding itself)</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">MyView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
      <span class="p">@</span><span class="n">State</span> <span class="kd">var</span> <span class="nv">myString</span> <span class="p">=</span> <span class="err">“</span><span class="n">Hello</span><span class="err">”</span>               <span class="c1">// 1</span>
      <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
          <span class="n">OtherView</span><span class="p">(</span><span class="n">sharedText</span><span class="p">:</span> <span class="err">$</span><span class="n">myString</span><span class="p">)</span>        <span class="c1">// 2</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">struct</span> <span class="nc">OtherView</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
      <span class="p">@</span><span class="n">Binding</span> <span class="kd">var</span> <span class="nv">sharedText</span><span class="p">:</span> <span class="n">string</span>             <span class="c1">// 3</span>
      <span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
          <span class="n">Text</span><span class="p">(</span><span class="n">sharedText</span><span class="p">)</span>                        <span class="c1">// 4</span>
          <span class="n">TextField</span><span class="p">(</span><span class="s">&quot;shared&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="err">$</span><span class="n">sharedText</span><span class="p">)</span>  <span class="c1">// 5 _myString.projectValue.projectValue</span>
      <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ol>
<li><code>_myString</code>是实际变量，包含一个<code>wrappedValue</code>，一个<code>projectedValue</code></li>
<li><code>myString</code>就是<code>_myString.wrappedValue</code></li>
<li><code>$myString</code>是<code>_myString.projectedValue</code>，<ul>
<li>是一个<code>Binding&lt;String&gt;</code>，传值和接值用的就是它</li>
<li>所以传<code>$myString</code>的地方也可以用<code>_myString.projectedValue</code>代替，学习阶段的话</li>
</ul>
</li>
<li>要把<code>projectedValue</code>层层传递下去，并不是用同一个<code>projectedValue</code>，而是设计成了<code>Binding&lt;T&gt;</code><ul>
<li>参考上面代码块的第5条</li>
</ul>
</li>
</ol>
<p>其它</p><ul>
<li>也可以绑定一个常量：<code>OtherView(sharedText: .constant(“Howdy”))</code></li>
<li>computed binding: <code>Binding(get:, set:).</code></li>
</ul>
<p>比如你的view是一个小组件，里面有一个<code>Binding var user: User</code>，那么在preview里面怎么传入这个User呢？用常量：</p><div class="highlight"><pre><span></span><span class="kd">static</span> <span class="kd">var</span> <span class="nv">preview</span><span class="p">:</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
    <span class="n">myView</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="p">.</span><span class="n">constant</span><span class="p">(</span><span class="n">User</span><span class="p">(...)))</span>
<span class="p">}</span>
</pre></div>
<h2>@EnvironmenetObject</h2>
<ul>
<li>The wrappedValue is: <code>ObservableObject</code> obtained via .environmentObject() sent to the View.</li>
<li>What it does: <code>invalidates</code> the View when wrappedValue does objectWillChange.send().</li>
<li>Projected value (i.e. $): a <code>Binding</code> (to the vars of the wrappedValue (a ViewModel)).</li>
</ul>
<p>与<code>@ObservedObject</code>用法稍有点不同，有单独的赋值接口：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">myView</span> <span class="p">=</span> <span class="n">MyView</span><span class="p">().</span><span class="n">environmentObject</span><span class="p">(</span><span class="n">theViewModel</span><span class="p">)</span>
<span class="c1">// 而@ObservedObject是一个普通的属性</span>
<span class="kd">let</span> <span class="nv">myView</span> <span class="p">=</span> <span class="n">MyView</span><span class="p">(</span><span class="n">viewModel</span><span class="p">:</span> <span class="n">theViewModel</span><span class="p">)</span>

<span class="c1">// Inside the View ...</span>
<span class="p">@</span><span class="n">EnvironmentObject</span> <span class="kd">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="n">ViewModelClass</span> 
<span class="c1">// ... vs ...</span>
<span class="p">@</span><span class="n">ObservedObject</span> <span class="kd">var</span> <span class="nv">viewModel</span><span class="p">:</span> <span class="n">ViewModelClass</span>
</pre></div>
<ul>
<li>visible to all views in your body (except modallay presented ones)</li>
<li>多用于多个view共享ViewModel的时候</li>
</ul>
<h2>@Environment</h2>
<ul>
<li>与<code>@EnvironmentObject</code>完全不是同一个东西</li>
<li>这是<code>Property Wrapper</code>不只有两个变量（warped..., projected...）的的一个应用</li>
<li>通过<code>keyPath</code>来使用：<code>@Environment(\.colorScheme) var colorScheme</code></li>
<li>wrappedValue的类型是通过<code>keyPath</code>声明时设置的</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">view</span><span class="p">.</span><span class="n">environment</span><span class="p">(</span><span class="err">\</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">,</span> <span class="p">.</span><span class="n">dark</span><span class="p">)</span>
</pre></div>
<p>so:</p><ul>
<li>The wrappedValue is: the value of some var in <code>EnvironmentValues</code>.</li>
<li>What it does: gets/sets a value of some var in <code>EnvironmentValues</code>.</li>
<li>Projected value (i.e. $): none.</li>
</ul>
<div class="highlight"><pre><span></span><span class="c1">// someView pop 一个 modal 的 myView,传递 environment</span>
<span class="n">someView</span><span class="p">.</span><span class="n">sheet</span><span class="p">(</span><span class="n">isPresented</span><span class="p">:</span> <span class="n">myCondition</span><span class="p">){</span>
    <span class="n">myView</span><span class="p">(...</span><span class="kd">init</span><span class="p">...)</span>
    <span class="p">.</span><span class="n">enviroment</span><span class="p">(</span><span class="err">\</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">,</span> <span class="n">colorScheme</span><span class="p">)</span> 
<span class="p">}</span>
</pre></div>
<p>除了深色模式，还有一个典型的应用场景就是编辑模式<code>\.editMode</code>，比如点了编辑按钮后。</p><blockquote>
<p><code>EditButton</code>是一个封装了UI和行为的控件，它只做一件事，就是更改<code>\.editmode</code>这个环境变量(的<code>isEditing</code>)</p></blockquote>
<h2>@Publisher</h2>
<p>It is an object that <code>emits values</code> and possibly a <code>failure object</code> if it fails while doing so.</p><div class="highlight"><pre><span></span><span class="n">Publisher</span><span class="p">&lt;</span><span class="n">Output</span><span class="p">,</span> <span class="n">Failure</span><span class="p">&gt;</span>
</pre></div>
<ul>
<li>Failure需要实现<code>Error</code>，如果没有，可以传<code>Never</code></li>
</ul>
<h3>订阅</h3>
<p>一种简单用法，<code>sink</code>:</p><div class="highlight"><pre><span></span><span class="n">cancellable</span> <span class="p">=</span> <span class="n">myPublisher</span><span class="p">.</span><span class="n">sink</span><span class="p">(</span>
    <span class="n">receiveCompletion</span><span class="p">:{</span><span class="n">resultin</span><span class="p">...},</span> <span class="c1">//result is a Completion&lt;Failure&gt; enum</span>
        <span class="n">receiveValue</span><span class="p">:</span> <span class="p">{</span> <span class="n">thingThePublisherPublishes</span> <span class="k">in</span> <span class="p">.</span> <span class="p">.</span> <span class="p">.</span> <span class="p">}</span>
  <span class="p">)</span>
</pre></div>
<p>返回一个<code>Cancellable</code>，可以随时<code>.cancel()</code>，只要你持有这个<code>cancellable</code>，就能随时用这个sink</p><p>View有自己的订阅方式：</p><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">onReceive</span><span class="p">(</span><span class="n">publisher</span><span class="p">)</span> <span class="p">{</span> <span class="n">thingThePublisherPublishes</span> <span class="k">in</span>
    <span class="c1">// do whatever you want with thingThePublisherPublishes </span>
<span class="p">}</span>
</pre></div>
<ol>
<li><code>.onReceive</code> will automatically <code>invalidate</code> your View (causing a redraw).</li>
<li>既然参数是publisher，所以是一个binding的变量，即带<code>$</code>使用：</li>
</ol>
<div class="highlight"><pre><span></span><span class="p">.</span><span class="n">onReceive</span><span class="p">(</span><span class="err">$</span><span class="n">aBindData</span><span class="p">)</span> <span class="p">{</span> <span class="n">bind_data</span> <span class="k">in</span> 
    <span class="c1">// my code</span>
<span class="p">}</span>
</pre></div>
<p>publisher来源：</p><ol>
<li><code>$</code> in front of vars marked <code>@Published</code><ul>
<li>还记得$就是取的projectedValue吗？</li>
<li>一般的projectedValue是一个<em>Binding</em>，Published的是是个<em>Publisher</em></li>
</ul>
</li>
<li>URLSession’s <code>dataTaskPublisher</code> (publishes the Data obtained from a URL)</li>
<li><code>Timer</code>’s publish(every:) (periodically publishes the current date and time as a Date)</li>
<li><code>NotificationCenter</code>’s publisher(for:) (publishes notifications when system events happen)</li>
</ol>
<blockquote>
<p>如果你有一个<code>ObservedObject</code>(Document)，它里面有一个<code>@Publisher</code>(background)，那么注意以下两者的区别：</p></blockquote>
<ul>
<li>document.<code>$</code>background: 是一个publisher</li>
<li><code>$</code>document.background: 是一个binding</li>
</ul>
<blockquote>
<p><code>.onReceive</code>只能接收<code>Publisher</code>的推送，而事实上，<code>onChange</code>（一般用于接收ObservedObject或State)同样也能接收Publisher。</p></blockquote>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B5%5D_Property-Wrapper/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B4%5D_Color_Image_Gesture/" target="_self">cs193p_2021笔记[4]_Color_Image_Gesture</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B4%5D_Color_Image_Gesture/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Color, UIColor &amp; CGColor</h1>
<p>Color:</p><ul>
<li>Is a color-specifier, e.g., <code>.foregroundColor(Color.green)</code>.</li>
<li>Can also act like a <code>ShapeStyle</code>, e.g., <code>.fill(Color.blue)</code>.</li>
<li>Can also act like a <code>View</code>, e.g., Color.white can appear <code>wherever</code> a View can appear.（可以当作view）</li>
</ul>
<p>UIColor:</p><ul>
<li>Is used to <code>manipulate</code> colors.（主打操控）</li>
<li>Also has many <code>more</code> built-in <code>colors</code> than <code>Color</code>, including “system-related” colors.(颜色更多)</li>
<li>Can be interrogated and can convert between color spaces.</li>
</ul>
<p>For example, you can get the RGBA values from a UIColor.
Once you have desired UIColor, employ <code>Color(uiColor:)</code> to use it in one of the roles above.</p><p>CGColor:</p><ul>
<li>The fundamental color representation in the Core Graphics drawing system</li>
<li><code>color.cgColor</code></li>
</ul>
<h1>Image V.S. UIImage</h1>
<p>Image:</p><ul>
<li>Primarily serves as a View.(主要功能是View)</li>
<li>Is <code>not</code> a type for vars that <code>hold an image</code> (i.e. a jpeg or gif or some such). That’s UIImage.</li>
<li>Access images in your Assets.xcassets (in Xcode) by name using <code>Image(_ name: String)</code>.</li>
<li>Also, many, many system images available via <code>Image(systemName:)</code>.</li>
<li>You can control the size of system images with <code>.imageScale()</code> View modifier.</li>
<li>System images also are affected by the .font modifier.</li>
<li>System images are also very useful <code>as masks</code> (for gradients, for example).</li>
</ul>
<p>UIImage</p><ul>
<li>Is the type for actually <code>creating/manipulating</code> images and <code>storing</code> in vars.</li>
<li>Very powerful representation of an image.</li>
<li>Multiple file formats, transformation primitives, animated images, etc.</li>
<li>Once you have the UIImage you want, use Image(uiImage:) to display it.</li>
</ul>
<h1>Multithreading</h1>
<ul>
<li>多线程其实并不是同时运行，而是前后台非常快速地切换</li>
<li><code>Queue</code>只是有顺序执行的代码，封装了<code>threading</code>的应用</li>
<li>这些“代码”用<code>closure</code>来传递</li>
<li><strong>main queue</strong>唯一能操作UI的线程<ul>
<li>主线程是单线程，所以不能执行异步代码</li>
</ul>
</li>
<li><strong>background queues</strong>执行任意：<em>long-lived, non-UI</em> tasks<ul>
<li>可以并行运行(running in parallel) -&gt; even with main UI queue</li>
<li>可以手动设置优先级，服务质量(<code>QoS</code>)等</li>
<li>优先级永远不可能超过main queue</li>
</ul>
</li>
<li>base API: GCD (<code>Grand Central Dispatch</code>)<ol>
<li>getting access to a queue</li>
<li>plopping a block of code on a queue</li>
</ol>
</li>
</ul>
<p>A: Creating a Queue</p><p>There are numerous ways to create a queue, but we’re only going to look at two ...</p><div class="highlight"><pre><span></span><span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span> <span class="c1">// the queue where all UI code must be posted</span>
<span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">(</span><span class="n">qos</span><span class="p">:</span> <span class="n">QoS</span><span class="p">)</span> <span class="c1">// a non-UI queue with a certain quality of service qos (quality of service) is one of the following ...</span>
    <span class="p">.</span><span class="n">userInteractive</span>    <span class="c1">// do this fast, the UI depends on it!</span>
    <span class="p">.</span><span class="n">userInitiated</span>  <span class="c1">// the user just asked to do this, so do it now</span>
    <span class="p">.</span><span class="n">utility</span>    <span class="c1">// this needs to happen, but the user didn’t just ask for it</span>
    <span class="p">.</span><span class="n">background</span> <span class="c1">// maintenance tasks (cleanups, etc.)</span>
</pre></div>
<p>B: Plopping a Closure onto a Queue</p><p>There are two basic ways to add a closure to a queue ...</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span> <span class="c1">//or</span>
<span class="kd">let</span> <span class="nv">queue</span> <span class="p">=</span> <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">global</span><span class="p">(</span><span class="n">qos</span><span class="p">:)</span> 
<span class="n">queue</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span> <span class="cm">/* code to execute on queue */</span> <span class="p">}</span>
<span class="n">queue</span><span class="p">.</span><span class="n">sync</span> <span class="p">{</span> <span class="cm">/* code to execute on queue */</span> <span class="p">}</span>
</pre></div>
<p>主线程里永远不要<code>.sync</code>, 那样会阻塞UI</p><div class="highlight"><pre><span></span><span class="n">DispatchQueue</span><span class="p">(</span><span class="n">global</span><span class="p">:</span> <span class="p">.</span><span class="n">userInitiated</span><span class="p">).</span><span class="k">async</span> <span class="p">{</span>
    <span class="c1">// 耗时代码</span>
    <span class="c1">// 不阻塞UI，也不能更新UI</span>
    <span class="c1">// 到主线程去更新UI</span>
    <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
        <span class="c1">// UI code can go here! we’re on the main queue! </span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h1>Gestures</h1>
<p>手势是iOS里的一等公民</p><div class="highlight"><pre><span></span><span class="c1">// recognize</span>
<span class="n">myView</span><span class="p">.</span><span class="n">gesture</span><span class="p">(</span><span class="n">theGesture</span><span class="p">)</span> <span class="c1">// theGesture must implement the Gesture protocol</span>

<span class="c1">// create</span>
<span class="kd">var</span> <span class="nv">theGesture</span><span class="p">:</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">TapGesture</span><span class="p">(</span><span class="bp">count</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1">// double tap</span>
<span class="p">}</span>

<span class="c1">// discrete gestures</span>
<span class="kd">var</span> <span class="nv">theGesture</span><span class="p">:</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">TapGesture</span><span class="p">(</span><span class="bp">count</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">.</span><span class="n">onEnded</span> <span class="p">{</span> <span class="cm">/* do something */</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 其实就是：</span>
<span class="kd">func</span> <span class="nf">theGesture</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
    <span class="n">tapGesture</span><span class="p">(</span><span class="bp">count</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// “convenience versions”</span>
<span class="n">myView</span><span class="p">.</span><span class="n">onTapGesture</span><span class="p">(</span><span class="bp">count</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* do something */</span> <span class="p">}</span> 
<span class="n">myView</span><span class="p">.</span><span class="n">onLongPressGesture</span><span class="p">(...)</span> <span class="p">{</span> <span class="cm">/* do something */</span> <span class="p">}</span>

<span class="c1">// non-discrete gestures</span>

<span class="kd">var</span> <span class="nv">theGesture</span><span class="p">:</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
      <span class="n">DragGesture</span><span class="p">(...)</span>
<span class="p">.</span><span class="n">onEnded</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span> <span class="cm">/* do something */</span> <span class="p">}</span>
</pre></div>
<p>non-discrete手势里传递的<code>value</code>是一个state:</p><ul>
<li>For a <code>DragGesture</code>, it’s a struct with things like the <code>start and end location</code> of the fingers.</li>
<li>For a <code>MagnificationGesture</code> it’s the <code>scale</code> of the magnification (how far the fingers spread out).</li>
<li>For a <code>RotationGesture</code> it’s the <code>Angle</code> of the rotation (like the fingers were turning a dial).</li>
<li>还可以跟踪一个state: <code>@GestureState var myGestureState: MyGestureStateType = &lt;starting value&gt;</code></li>
</ul>
<p>唯一可以更新这个<code>myGestureState</code>的机会：</p><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">theGesture</span><span class="p">:</span> <span class="n">some</span> <span class="n">Gesture</span> <span class="p">{</span>
     <span class="n">DragGesture</span><span class="p">(...)</span>
        <span class="p">.</span><span class="n">updating</span><span class="p">(</span><span class="err">$</span><span class="n">myGestureState</span><span class="p">)</span> <span class="p">{</span> <span class="n">value</span><span class="p">,</span> <span class="n">myGestureState</span><span class="p">,</span> <span class="n">transaction</span> <span class="k">in</span> 
            <span class="n">myGestureState</span> <span class="p">=</span> <span class="cm">/* usually something related to value */</span>
        <span class="p">}</span>
        <span class="p">.</span><span class="n">onEnded</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span> <span class="cm">/* do something */</span> <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
<p>注意<code>$</code>的用法</p><p>如果不需要去计算一个<code>gestureState</code>传出去的话，有个<code>updating</code>用简版：</p><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">onChanged</span> <span class="p">{</span> <span class="n">value</span> <span class="k">in</span>
<span class="cm">/* do something with value (which is the state of the fingers) */</span>
<span class="p">}</span>
</pre></div>
<p>事实上，目前来看<code>gestureState</code>只做了两件事：</p><ol>
<li>把实时手势对应的值保存起来</li>
<li>在手势结束时复原（对于缩放，变为1，对于移动，变为0）</li>
<li>同时，它是只读的，只在<code>.updating</code>方法里有更新的机会</li>
</ol>
<p>所以，如果你的UI和动画逻辑，用到了手势结束时的值（即需要它复原），那么你也可以直接在<code>.onEnded</code>方法里手动把它设回去，等同于你也实现了你的<code>gestureState</code>，并且没有它那些限制。</p><h2>Drag and Drop</h2>
<h3>Item Provider</h3>
<ul>
<li>The heart of drag nad drop is the <code>NSItemProvider</code> class.</li>
<li>It facilitates the transfer of data between processes (via drag and drop, for example)</li>
<li>It facilitates the transfer of a number of data types in iOS, for example:<ul>
<li>NSAttributedString and NSString</li>
<li>NSURL</li>
<li>UIImage and UIColor</li>
</ul>
</li>
<li>pre-Swift，所以需要bridging，比如：<code>String as NSString</code></li>
</ul>
<p>结合几个要点，一句话就能让你的元素能被拖动(drag)：</p><div class="highlight"><pre><span></span><span class="n">Text</span><span class="p">(</span><span class="n">emoji</span><span class="p">).</span><span class="n">onDrag</span><span class="p">{</span> <span class="bp">NSItemProvider</span><span class="p">(</span><span class="n">object</span><span class="p">:</span> <span class="n">emoji</span> <span class="k">as</span> <span class="bp">NSString</span><span class="p">)}</span>
</pre></div>
<p>而接收(drop)则要复杂很多：</p><div class="highlight"><pre><span></span><span class="n">otherView</span><span class="p">.</span><span class="n">onDrop</span><span class="p">(</span><span class="n">of</span><span class="p">:</span> <span class="p">[.</span><span class="n">plainText</span><span class="p">],</span> <span class="n">isTarget</span><span class="p">:</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span><span class="n">providers</span><span class="p">,</span> <span class="n">location</span> <span class="k">in</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
</pre></div>
<ul>
<li>参接收的类型由<code>of</code>参数指定，这里假定是文本</li>
<li>方法里最终要返回一个bool值，表示成功接收与否，我返了个false，意思是你能让物体拖动，但是一松开手指就复原了</li>
</ul>
<p>从<code>itemprovider</code>里加载对象有模板代码：</p><div class="highlight"><pre><span></span><span class="kd">extension</span> <span class="nc">Array</span> <span class="k">where</span> <span class="n">Element</span> <span class="p">==</span> <span class="bp">NSItemProvider</span> <span class="p">{</span>
  <span class="kd">func</span> <span class="nf">loadObjects</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">ofType</span> <span class="n">theType</span><span class="p">:</span> <span class="n">T</span><span class="p">.</span><span class="kr">Type</span><span class="p">,</span> <span class="n">firstOnly</span><span class="p">:</span> <span class="nb">Bool</span> <span class="p">=</span> <span class="kc">false</span><span class="p">,</span> <span class="n">using</span> <span class="n">load</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Void</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="bp">NSItemProviderReading</span> <span class="p">{</span>
    <span class="k">if</span> <span class="kd">let</span> <span class="nv">provider</span> <span class="p">=</span> <span class="bp">first</span><span class="p">(</span><span class="k">where</span><span class="p">:</span> <span class="p">{</span> <span class="nv">$0</span><span class="p">.</span><span class="n">canLoadObject</span><span class="p">(</span><span class="n">ofClass</span><span class="p">:</span> <span class="n">theType</span><span class="p">)})</span> <span class="p">{</span>
      <span class="n">provider</span><span class="p">.</span><span class="n">loadObject</span><span class="p">(</span><span class="n">ofClass</span><span class="p">:</span> <span class="n">theType</span><span class="p">)</span> <span class="p">{</span> <span class="n">object</span><span class="p">,</span> <span class="n">error</span> <span class="k">in</span>
        <span class="k">if</span> <span class="kd">let</span> <span class="nv">value</span> <span class="p">=</span> <span class="n">object</span> <span class="k">as</span><span class="p">?</span> <span class="n">T</span> <span class="p">{</span>
          <span class="n">DispatchQueue</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="k">async</span> <span class="p">{</span>
              <span class="n">load</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="kc">true</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="kc">false</span>
  <span class="p">}</span>

<span class="c1">// and</span>
<span class="c1">// where T: _ObjectiveCBridgeable, T._ObjectiveCType: NSItemProviderReading</span>
</pre></div>
<ol>
<li>提供了两段代码，可以看到其实就是对要加载的对象的约束不同，提供了对OC的兼容</li>
<li>模板代码演示了</li>
</ol>
<p>稳健地从拖拽对象加载内容（canload -&gt; load)
3. 真正的业务逻辑其实就是为拖进来的这个view选择一个位置存放（或读取它携带的数据）
4. <code>T.Type</code>传的是类别的<code>.self</code>，比如<code>String.self</code></p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B4%5D_Color_Image_Gesture/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B3%5D_Animation_Transition/" target="_self">cs193p_2021笔记[3]_Animation_Transition</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B3%5D_Animation_Transition/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Animation</h1>
<ul>
<li>One way to do animation is by animating a Shape.</li>
<li>The other way to do animation is to animate Views via their <code>ViewModifiers</code>.</li>
<li>Only <code>changes</code> can be animated<ul>
<li>ViewModifier arguments (not all, i.e. fonts)</li>
<li>Shapes</li>
<li>the <em>existance</em> of a View in the UI<ul>
<li>比如if-else和ForEach</li>
</ul>
</li>
</ul>
</li>
<li>You can only animate changes to Views in <em>containers that are already on screen</em> (<code>CTAAOS</code>).</li>
</ul>
<p>两个golden rule:</p><ol>
<li>要有view modifier的属性变化</li>
<li>要在屏幕上</li>
</ol>
<p>才会触发动画（其实就是上面的最后两条）</p><ul>
<li>课程的动画例子里，用了if-else来生成view，这样导致了新生成的view不会触发动画</li>
<li>比如点开两张牌，新点开的那张牌由于之前牌的内容并没有出现在屏幕上，导致动画没有触发</li>
<li>所以把view的结构由if-else的生成和销毁机制，变成了透明度切换机制<ul>
<li>即正面和反面都在屏幕上，只不过透明度相反，以在视觉上要么是正面要么是反面</li>
<li>本以为透明度为0就会销毁视图(UIKit？)，看样子并不是这样的，大胆用opacity就好了</li>
</ul>
</li>
</ul>
<h2>隐式调用</h2>
<div class="highlight"><pre><span></span><span class="n">Text</span><span class="p">(</span><span class="err">“👻</span> <span class="err">”</span><span class="p">)</span>
    <span class="p">.</span><span class="n">opacity</span><span class="p">(</span><span class="n">scary</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span><span class="p">)</span>                             <span class="c1">// 普通modifier, 即如果没有动画，也需要的状态（即代码也不会删）</span>
    <span class="p">.</span><span class="n">rotationEffect</span><span class="p">(</span><span class="n">Angle</span><span class="p">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">upsideDown</span> <span class="p">?</span> <span class="mi">180</span> <span class="p">:</span> <span class="mi">0</span><span class="p">))</span>    <span class="c1">// 动画modifier，即定制的动画效果，不需要动画的时候，就不需要这一行</span>
    <span class="p">.</span><span class="n">animation</span><span class="p">(</span><span class="n">Animation</span><span class="p">.</span><span class="n">easeInOut</span><span class="p">)</span>                         <span class="c1">// 触发</span>
</pre></div>
<ul>
<li>上述所有<code>ViewModifier</code>都会被动画<ul>
<li><code>scary, upsideDown</code>等值改变时也会触发动画</li>
</ul>
</li>
<li>隐式调用会冒泡（所以不要对一个container view做<code>.animation</code>，还有定位的问题)</li>
<li>animation的参数就是一个struct： duration, delay, repeat, curve...</li>
</ul>
<p>对于不能动画的modifier，看一下这个实例（上为修改前，下为修改后）
<figure  style="flex: 51.452991452991455" ><img width="1204" height="1170" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4804373fb223c0a4333d720331093521.png" alt=""/></figure></p><ol>
<li>把font设为常量，把缩放变成一个geometric effect</li>
<li>同时也说明<code>.animation()</code>不止作用于它前面的</li>
</ol>
<h2>显式调用</h2>
<div class="highlight"><pre><span></span><span class="n">withAnimation</span><span class="p">(.</span><span class="n">linear</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// do something that will cause ViewModifier/Shape arguments to </span>
<span class="n">change</span> <span class="n">somewhere</span> <span class="p">}</span>
</pre></div>
<ul>
<li>It will appear in closures like <code>.onTapGesture</code>.</li>
<li>显式动画不会覆盖掉隐式动画</li>
<li>很少有处理用户手势而不包<code>.withAnimation</code>的</li>
</ul>
<h1>Transition</h1>
<ul>
<li>转场，主要用于view的出现和消失</li>
<li>一对<code>ViewModifier</code>，一个<code>before</code>, 一个<code>after</code></li>
</ul>
<div class="highlight"><pre><span></span><span class="n">ZStack</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">isFaceUp</span> <span class="p">{</span>
        <span class="n">RoundedRectangle</span><span class="p">()</span> <span class="c1">// default .transition is .opacity </span>
        <span class="n">Text</span><span class="p">(</span><span class="err">“👻</span> <span class="err">”</span><span class="p">).</span><span class="n">transition</span><span class="p">(.</span><span class="n">scale</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">RoundedRectangle</span><span class="p">(</span><span class="n">cornerRadius</span><span class="p">:</span> <span class="mi">10</span><span class="p">).</span><span class="n">transition</span><span class="p">(.</span><span class="n">identity</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>Unlike .animation(), .transition() does not get redistributed to a container’s content Views. So putting .transition() on the ZStack above only works if the entire ZStack came/went.</p><p>(Group and ForEach do distribute .transition() to their content Views, however.)</p><p>意思是<code>.transition</code>并不会向下传递，如果对<code>ZStack</code>做转场，只会把整个容器进行转场而不是里面的view（见实例二）</p><ul>
<li>转场只是一个声明，并没有触发动画（其实就是设置了<code>ViewModifier</code>）</li>
<li>所以转场没有隐式调用</li>
<li>只对CTAAOS有用</li>
</ul>
<p><code>.onAppear</code>或<code>.onDisappear</code>时，container必然是在屏幕上的，所以这是一个写<code>.transition</code>的好地方（记得要<code>withAnimation</code>)</p><p>built-in transitions:</p><ul>
<li>AnyTransition.opacity: 通过<code>.opacity</code> modifier来实现淡入淡出</li>
<li>AnyTransition.scale: 通过<code>.frame</code> modifier来实现缩放</li>
<li>AnyTransition.offset(CGSize): 通过<code>.offset</code>来实现移动</li>
<li>AnyTransition.modifier(active:identity:): 你提供两个<code>ViewModifier</code></li>
</ul>
<p>通过<code>AnyTransition.animation</code>(Animation`)来定制动画细节：</p><div class="highlight"><pre><span></span><span class="p">.</span><span class="n">transition</span><span class="p">(.</span><span class="n">opacity</span><span class="p">.</span><span class="n">animation</span><span class="p">(.</span><span class="n">linear</span><span class="p">(</span><span class="n">duration</span><span class="p">:</span> <span class="mi">20</span><span class="p">)))</span>
</pre></div>
<h1>动画机制</h1>
<p>其实就是给出一系列的数据点，系统会根据这些数据点把时间切分，你给的数据点越多，切的时间块也就越多，而且系统会根据你的线性函数来决定是平均还是怎样去切分这些时间块：</p><ul>
<li>the animation system divides the animation duration up into little pieces.</li>
<li>The animation system then tells the Shape/ViewModifier the current piece it should show.</li>
<li>And the Shape/ViewModifier makes sure that its code always reflects that.</li>
</ul>
<p>系统通知变量当前的值，UI根据这个值实时绘制当前的View，不断销毁重建，就是动画的过程。</p><p>系统是用一个变量来通知这个进度的：<code>Animatable</code> protocol的唯一成员变量：<code>animatableData</code>:</p><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">animatableData</span><span class="p">:</span> <span class="kr">Type</span>
</pre></div>
<ul>
<li>Type只需要满足<code>VectorArithmetic</code>协议，其实就是一个可以被细分的值，基本上是Float, Double, CGFloat，以及<code>AnimatablePair</code>(其实就是两个<code>VectorArithmetic</code>)</li>
<li>想要支持动画的<code>Shape</code>, <code>ViewModifier</code>，只需要实现<code>Animatable</code>协议即可（即提供一个<code>animatableData</code>属性）</li>
</ul>
<p>Because it’s communicating both ways, this animatableData is a <code>read-write</code> var.</p><ul>
<li>The <code>setting</code> of this var is the animation system telling the Shape/VM which piece to draw.</li>
<li>The <code>getting</code> of this var is the animation system getting the <code>start/end</code> points of an animation.</li>
</ul>
<p><strong>实例一</strong></p><figure  style="flex: 73.625" ><img width="1178" height="800" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/10d0bb779b10383a36d23d581f2fadb9.png" alt=""/></figure><ul>
<li>view modifier里面有一个变量<code>rotation</code>（ZStack, content, rotation3DEffect)</li>
<li>那么外层在<code>withAnimation{}</code>的时候，我们是期望rotation的值能动起来的<ul>
<li>内置的viewmodifier当然会自己动，如<code>opacity</code>等</li>
</ul>
</li>
<li>那么我们首先就要让<code>Cardify</code> conform to <code>Animatable</code>（例子中的AnimatableModifer = Animatable + ViewModifer)</li>
<li>然后我们就要实现<code>animatableData</code>, 因为系统事实上就是不断去更新这个data值</li>
<li>教材里把它进行了封装（当然你也可以直接用它），这只是思维方式上的区别</li>
<li><code>animatedData</code>会随时间变化，自然会不断invalidate view，然后rebuild view，动画就产生了。</li>
</ul>
<p><strong>实例二</strong></p><p>课程里有这么个需求：卡片由<code>LazyVGrid</code>提供布局，且卡片出现和消失的时候都要有动画。</p><p>出现和消失？那当然就是<code>Transition</code>的事了:</p><div class="highlight"><pre><span></span><span class="n">Card</span><span class="p">()</span>
  <span class="p">.</span><span class="n">transition</span><span class="p">(</span><span class="n">AnyTransition</span><span class="p">.</span><span class="n">asymmetric</span><span class="p">(</span><span class="n">insertion</span><span class="p">:</span> <span class="p">.</span><span class="n">scale</span><span class="p">,</span> 
                                         <span class="n">removal</span><span class="p">:</span> <span class="p">.</span><span class="n">opacity</span><span class="p">)))</span>
</pre></div>
<p>运行时发现消失的时候有动画，出现的动画却没有。原因是<code>transition</code>只会在<em>出现和消失</em>时触发，而我们的卡片是包在grid容器里的，所以grid出现在屏幕上的时候，就带着卡片一起出现了，transition并不会向下传递（前文也已经说过了，这里刚好印证）。</p><ol>
<li>所以解决方法当然可以“延迟”呈现这些卡片</li>
<li>课程里用了另一种方法，机制当然也是延迟，但不是那么地直白：</li>
</ol>
<figure  style="flex: 82.95774647887323" ><img width="1178" height="710" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e7e3ef2ac16296fabf73162c1fc678fa.png" alt=""/></figure><ul>
<li>就是利用了<code>.onAppear</code>来阻断容器和卡片的连续生成，而改用容器呈现后，再逐个“添加”的方式，让每一张卡片都有一个单独出现的机会</li>
<li>同时也必须利用<code>@State</code>, 让每添加一张卡片都会invalidate view一次</li>
<li>也能看出，animate能animate的就是属性和transition</li>
</ul>
<blockquote>
<p>当然，课程最后改成了“发牌”的机制，手动添加卡片，彻底阻断了卡片和容器一起出现的场景。</p></blockquote>
<p>这就带我们来到了实例三，同一个view在不同容器间的动画，怎么计算各自尺度下同一个view的位置：<code>matchedGeometryEffect</code></p><p><strong>实例三</strong></p><figure  style="flex: 73.45679012345678" ><img width="1190" height="810" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/08935bf9006d072875c203895aff17b7.png" alt=""/></figure><ul>
<li>想要有牌一张张发出去的效果，自然会想到添加延时</li>
<li>实现成了同时做动画，只不过越到后面的牌，延时越长（动作越慢），而不是我们想象的先后触发</li>
</ul>
<p>为了让不同的牌发出去时有立体效果，还以index为依据设置了<code>zIndex</code>，最终效果：</p><figure class="vertical-figure" style="flex: 24.608819345661452" ><img width="346" height="703" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/c16a9ce3d925f64e63cdc14ebd2b5f59.gif" alt=""/></figure></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021%E7%AC%94%E8%AE%B0%5B3%5D_Animation_Transition/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B2%5D/" target="_self">cs193p_2021_笔记[2]</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B2%5D/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>本文涉及内容：<code>ViewModifier, Property Observers, Layout</code></p><hr />
<h1>ViewModifier</h1>
<p><code>.aspectRatio(2/3)</code> is likely something like <code>.modifier(AspectModifier(2/3))</code> AspectModifier can be <code>anything</code> that conforms to the <code>ViewModifier</code> protocol ...</p><p>它只有一个body方法：</p><div class="highlight"><pre><span></span><span class="kd">protocol</span> <span class="nc">ViewModifier</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="n">Content</span> <span class="c1">// this is a protocol’s version of a“don’t care” </span>
    <span class="kd">func</span> <span class="nf">body</span><span class="p">(</span><span class="n">content</span><span class="p">:</span> <span class="n">Content</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">some</span> <span class="n">View</span> <span class="n">that</span> <span class="n">represents</span> <span class="n">a</span> <span class="n">modification</span> <span class="n">of</span> <span class="n">content</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ul>
<li>对一个view调用<code>.modifier</code>就是把这个view传成了上述body方法的content</li>
<li>而从<code>.modifer</code>变成<code>.cardify</code>，不过是用了<code>extension</code>：</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">extension</span> <span class="nc">View</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="nf">cardify</span><span class="p">(</span><span class="n">isFaceUp</span><span class="p">:</span> <span class="nb">Bool</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">View</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kc">self</span><span class="p">.</span><span class="n">modifier</span><span class="p">(</span><span class="n">Cardify</span><span class="p">(</span><span class="n">isFaceUp</span><span class="p">:</span> <span class="n">isFaceUp</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h1>Property Observers</h1>
<ul>
<li>语法长得像<code>computed var</code>, 但完全不是一回事 （get, set之于willSet, didSet）</li>
<li>willSet, didSet，对应newValue, oldValue</li>
</ul>
<h2>@State</h2>
<p>your view is <strong>Read Only</strong>,</p><p>为什么？</p><blockquote>
<p>因为view的生命周期足够短，基本上是不断地生成和销毁，根本不需要”被改变“</p></blockquote>
<ul>
<li>所以永远用<code>let</code></li>
<li>所以是<code>stateles</code>的</li>
</ul>
<p>这样的结构很简单，任何view的变化其实就是重绘。</p><p>仍然有些时候需要状态：</p><ul>
<li>编辑表单</li>
<li>模态窗口或通知窗口等临时窗口</li>
<li>动画需要追踪动画进度</li>
</ul>
<p>声明：</p><div class="highlight"><pre><span></span><span class="p">@</span><span class="n">State</span> <span class="kd">private</span> <span class="kd">var</span> <span class="nv">somethingTemporary</span><span class="p">:</span> <span class="n">SomeType</span> <span class="c1">// this can be of any type</span>
</pre></div>
<ul>
<li>private 表示别人访问不到</li>
<li>@State的的变化会在<strong>必要时</strong>引起重绘 （相当于一个<code>@ObservedObject</code>）</li>
<li>view会不断销毁和重建 -&gt; 指针会永远指向新的内存地址</li>
<li>而state是在堆上分配的空间</li>
<li>所以销毁和重建view并不会丢失state</li>
<li>后文<code>property wrapper</code>详述</li>
</ul>
<h1>Layout</h1>
<ol>
<li><code>Container</code>提供空间</li>
<li><code>Views</code>确定自身的大小</li>
<li><code>Container</code>提供<code>View</code>的位置</li>
<li><code>Container</code>确定自身大小（等同于#2)</li>
</ol>
<h2>HStack and VStack</h2>
<p>横/纵向排列元素(View)，并提供“尽可能小”的空间，根据元素性质，有三种场景：</p><ol>
<li><code>inflexble</code> view: <code>Image</code>，fixed size</li>
<li>slightly more flexible view: <code>Text</code>，适应文字的合适大小</li>
<li>very flexible view: <code>RoundedRectangle</code>: 占满空间 -&gt; 基本上<code>Shape</code>都会有多少空间占多少</li>
</ol>
<ul>
<li>一旦元素确定了size，多余的空间就会给下一个元素，最后<code>very flexible view</code>平均分配剩下的空间</li>
<li>所有元素大小确定，容器大小也就确定了，如果有<code>very flexible</code>的，那么容易本身也是<code>very flexible</code>的</li>
</ul>
<p>remark：</p><ul>
<li><code>Spacer(minLength: CGFloat)</code> 空格, draw nothing, 占尽可能多的空间</li>
<li><code>Divider()</code> 画条分隔线，占尽可能小的空间</li>
<li><code>.layoutPriority(100)</code> 用优先级来表示分配空间的顺序，默认值为0。后分配者如果没有空间了会用省略号表示</li>
<li><code>HStack(alignment: .leading)</code>用来控制元素的对齐</li>
</ul>
<blockquote>
<p>List, Form, OutlineGroup 其实就是 <code>really smart VStacks</code>，即本质上就是一个纵向排列的布局。</p></blockquote>
<h2>LazyHStack and LazyVStack</h2>
<ul>
<li><em>Lazy</em>的意思是如果元素对应的位置没有出现在屏幕上，就不会构建View.</li>
<li>they also size themselves to fit their views</li>
<li>前两条加一起，得出这个容器不会尽可能多的占用空间，即使含有very flexible的view -&gt; 尽可能小的空间</li>
<li>显然，它最多出现在<code>ScrollView</code>里（只有在有限窗口里滚动，才有可见不可见的差别）</li>
</ul>
<h2>Scrollview</h2>
<ul>
<li>给多少空间占多少空间</li>
</ul>
<h2>LazyHGrid and LazyVGrid</h2>
<ul>
<li>一个方向view数量固定，另一个方向动态增减（scroll）的H/V stack，以竖向的<code>LazyVGrid</code>为例：</li>
<li>确定每行元素个数，多少行由元素总数决定</li>
<li>或者确定元素大小，在行方向铺满后，再往下一行铺</li>
<li>HGrid方向则是先纵向铺满，再水平铺</li>
</ul>
<h2>ZStack</h2>
<ul>
<li>sizes itself to fit its children</li>
<li>can be very flexible (if one children is)</li>
</ul>
<p>两个modifier其实也是用的ZStack:</p><ul>
<li><code>.background</code>，插入一个view在底层，stack起来: <code>Text(&quot;hello&quot;).background(Rectangle().foregroundColor(.red))</code></li>
<li><code>.overlay</code>，覆盖到表层的zstack: <code>Circle().overlay(Text(&quot;hello&quot;), alignment:.center)</code></li>
</ul>
<p>More：</p><ul>
<li>一个view是可以选择任意size的，哪怕比给它的空间更大(产生裁剪)</li>
<li><code>.aspectRatio(2/3, contentMode: .fit)</code>如果是在HStack里，<ul>
<li>则是把元素横向排列后得到宽度，根据宽度计算出高度，得到元素大小</li>
<li><code>.fit</code>表示完整显示图片（就长边），短边部分补成黑色，<code>.fill</code>应该是就短边，长边部分就裁剪了</li>
</ul>
</li>
</ul>
<div class="highlight"><pre><span></span><span class="n">HStack</span> <span class="p">{</span>
    <span class="n">ForEach</span><span class="p">(</span><span class="n">cards</span><span class="p">)</span> <span class="p">{</span> <span class="n">card</span> <span class="k">in</span>
        <span class="n">CardView</span><span class="p">(</span><span class="n">card</span><span class="p">).</span><span class="n">aspectRatio</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span> <span class="n">contentMode</span><span class="p">:</span> <span class="p">.</span><span class="n">fit</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
    <span class="p">.</span><span class="n">foregroundColor</span><span class="p">(.</span><span class="n">orange</span><span class="p">)</span>
    <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
<ol>
<li>在能够分配的空间里，四边各减10 -&gt; padding(10)</li>
<li>减10后的空间里，根据aspectRation确定一个size</li>
<li>这个size应用给CardView</li>
<li>组合成HStack的size</li>
</ol>
<p>总大小就是HStack的size四边各加10</p><p>而View们如何知道能占多少空间？-&gt; <code>GeometryReader</code></p><h2>GeometryReader</h2>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
    <span class="n">GeometryReader</span> <span class="p">{</span> <span class="n">geometry</span> <span class="k">in</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>参数<code>geometry</code>是一个<code>GeometryProxy</code>:</p><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">GeometryProxy</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nv">size</span><span class="p">:</span> <span class="n">CGSize</span>
    <span class="kd">var</span> <span class="nv">safeAreaInsets</span><span class="err">：</span> <span class="n">EdgeInsets</span>
    <span class="kd">func</span> <span class="nf">frame</span><span class="p">(</span><span class="k">in</span><span class="p">:</span> <span class="n">CoordinateSpace</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">CGRect</span>
<span class="p">}</span>
</pre></div>
<ul>
<li><code>size</code>表示被提供了多少的空间（by its container)</li>
<li>并且不包含safe area（如刘海）</li>
<li>如果需要绘制到safe area里去: <code>ZStack{...}.edgesIgnoringSafeArea([.top])</code></li>
</ul>
<figure  style="flex: 127.6086956521739" ><img width="1174" height="460" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/aa2a99b80008d002cfc2521af182c43d.png" alt=""/></figure><p>图中演示的是设置卡片字体的大小，希望尽可能地填充卡片，<code>geometry.size</code>能给出运行时数据，而无需硬编码。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B2%5D/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B1%5D/" target="_self">cs193p_2021_笔记[1]</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B1%5D/" target="_self">
                <time class="text-uppercase">
                    October 24 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>2020年看了一遍，后来学深度学习去了，然后发现2021也出来了，仍然是视频授课（对我们没区别），看完后整理了两年课程的笔记。</p><p>本文涉及内容：<code>struct, enum, optional, protocol, viewbuilder, shape</code></p><h1>struct and class</h1>
<p>拥有差不多的结构</p><ul>
<li>stored vars</li>
<li>computed vars</li>
<li>constant lets</li>
<li>functions</li>
<li>initializers</li>
</ul>
<p>differents:
struct | class
-------|------
Value type | Reference type
Copied when passed or assigned | Passed around via pointers 
Copy on write | Automatically reference counted 
Functional programming | Object-oriented programming 
No inheritance | Inheritance (single) 
“Free”（缺省） init initializes ALL vars | “Free” init initializes NO vars 
Mutability must be explicitly stated | Always mutable (即使用let, 只表示不会改变指针)
Your “go to” data structure | Used in specific circumstances
Everything you’ve seen so far is a struct (except View which is a protocol) | The ViewModel in MVVM is always a class (also, UIKit (old style iOS) is class-based)</p><h1>泛型，函数类型,闭包</h1>
<ul>
<li>允许未知类型，但swift是强类型，所以用类型占位符，用作参数时参考.net的泛型</li>
<li>函数也是一种类型，可以当作变量，参数，出现在变量，参数的位置</li>
<li>in-line风格的函数叫<code>closure</code>(闭包)</li>
</ul>
<h1>enum</h1>
<ul>
<li>枚举是值类型</li>
<li>枚举的每个state都可以有<code>associated data</code>（等于是把每个state看成一个class/struct，associated data就可以理解为<strong>属性</strong>)</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">FastFoodMenuItem</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">hamburger</span><span class="p">(</span><span class="n">numberOfPatties</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">fries</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="n">FryOrderSize</span><span class="p">)</span>
    <span class="k">case</span> <span class="n">drink</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="n">ounces</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="c1">// the unnamed String is the brand, e.g. “Coke”</span>
    <span class="k">case</span> <span class="n">cookie</span> <span class="p">}</span>

<span class="kd">enum</span> <span class="nc">FryOrderSize</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">large</span>
    <span class="k">case</span> <span class="n">small</span> <span class="p">}</span>

<span class="kd">let</span> <span class="nv">menuItem</span><span class="p">:</span> <span class="n">FastFoodMenuItem</span> <span class="p">=</span> <span class="n">FastFoodMenuItem</span><span class="p">.</span><span class="n">hamburger</span><span class="p">(</span><span class="n">patties</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">otherItem</span><span class="p">:</span> <span class="n">FastFoodMenuItem</span> <span class="p">=</span> <span class="n">FastFoodMenuItem</span><span class="p">.</span><span class="n">cookie</span>
<span class="kd">var</span> <span class="nv">yetAnotherItem</span> <span class="p">=</span> <span class="p">.</span><span class="n">cookie</span> <span class="c1">// Swift can’t figure this out</span>
</pre></div>
<ol>
<li>FryOrderSize同时又是一个枚举</li>
<li>状态drink拥有两个“属性”，而且其中一个还<strong>未命名</strong></li>
</ol>
<h2>break and fall through/defaults</h2>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">menuItem</span> <span class="p">=</span> <span class="n">FastFoodMenuItem</span><span class="p">.</span><span class="n">cookie</span>
<span class="k">switch</span> <span class="n">menuItem</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="n">hamburger</span><span class="p">:</span> <span class="k">break</span>  <span class="c1">// break</span>
    <span class="k">case</span> <span class="p">.</span><span class="n">fries</span><span class="p">:</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">fries</span><span class="err">”</span><span class="p">)</span>
    <span class="k">default</span><span class="p">:</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">other</span><span class="err">”</span><span class="p">)</span> <span class="c1">// default</span>
<span class="p">}</span>
</pre></div>
<ol>
<li>如果把drink写上，但没有方法体，则叫<code>fall through</code>，只会往后面一个state fall through</li>
<li>如果漏写了drink，则会匹配到default项（cookie同理）</li>
</ol>
<h2>with associated data</h2>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">menuItem</span> <span class="p">=</span> <span class="n">FastFoodMenuItem</span><span class="p">.</span><span class="n">drink</span><span class="p">(</span><span class="err">“</span><span class="n">Coke</span><span class="err">”</span><span class="p">,</span> <span class="n">ounces</span><span class="p">:</span> <span class="mi">32</span><span class="p">)</span>
  <span class="k">switch</span> <span class="n">menuItem</span> <span class="p">{</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">hamburger</span><span class="p">(</span><span class="kd">let</span> <span class="nv">pattyCount</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">a</span> <span class="n">burger</span> <span class="n">with</span> <span class="err">\</span><span class="p">(</span><span class="n">pattyCount</span><span class="p">)</span> <span class="n">patties</span><span class="p">!</span><span class="err">”</span><span class="p">)</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">fries</span><span class="p">(</span><span class="kd">let</span> <span class="nv">size</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">a</span> <span class="err">\</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="n">order</span> <span class="n">of</span> <span class="n">fries</span><span class="p">!</span><span class="err">”</span><span class="p">)</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">drink</span><span class="p">(</span><span class="kd">let</span> <span class="nv">brand</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">ounces</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">a</span> <span class="err">\</span><span class="p">(</span><span class="n">ounces</span><span class="p">)</span><span class="n">oz</span> <span class="err">\</span><span class="p">(</span><span class="n">brand</span><span class="p">)</span><span class="err">”</span><span class="p">)</span>
      <span class="k">case</span> <span class="p">.</span><span class="n">cookie</span><span class="p">:</span> <span class="bp">print</span><span class="p">(</span><span class="err">“</span><span class="n">a</span> <span class="n">cookie</span><span class="p">!</span><span class="err">”</span><span class="p">)</span>
 <span class="p">}</span>
</pre></div>
<h2>可以拥有方法</h2>
<p>这就可以扩展出computed vars</p><div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">FastFoodMenuItem</span> <span class="p">{</span> <span class="p">...</span>
      <span class="kd">func</span> <span class="nf">isIncludedInSpecialOrder</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="nb">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="nb">Bool</span> <span class="p">{</span>
          <span class="k">switch</span> <span class="kc">self</span> <span class="p">{</span>
            <span class="k">case</span> <span class="p">.</span><span class="n">hamburger</span><span class="p">(</span><span class="kd">let</span> <span class="nv">pattyCount</span><span class="p">):</span> <span class="k">return</span> <span class="n">pattyCount</span> <span class="p">==</span> <span class="n">number</span>
            <span class="k">case</span> <span class="p">.</span><span class="n">fries</span><span class="p">,</span> <span class="p">.</span><span class="n">cookie</span><span class="p">:</span> <span class="k">return</span> <span class="kc">true</span> <span class="c1">// a drink and cookie in every special order </span>
            <span class="k">case</span> <span class="p">.</span><span class="n">drink</span><span class="p">(</span><span class="kc">_</span><span class="p">,</span> <span class="kd">let</span> <span class="nv">ounces</span><span class="p">):</span> <span class="k">return</span> <span class="n">ounces</span> <span class="p">==</span> <span class="mi">16</span> <span class="c1">// &amp; 16oz drink of any kind</span>
 <span class="p">}</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h2>Iterable</h2>
<p>conform <code>CaseIterable</code>协议就能被遍历，因为增加了一个<code>allCases</code>的静态变量：</p><div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">TeslaModel</span><span class="p">:</span> <span class="n">CaseIterable</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">X</span>
      <span class="k">case</span> <span class="n">S</span>
      <span class="k">case</span> <span class="n">Three</span>
      <span class="k">case</span> <span class="n">Y</span>
<span class="p">}</span>
<span class="k">for</span> <span class="n">model</span> <span class="k">in</span> <span class="n">TeslaModel</span><span class="p">.</span><span class="n">allCases</span> <span class="p">{</span>
    <span class="n">reportSalesNumbers</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">reportSalesNumbers</span><span class="p">(</span><span class="k">for</span> <span class="n">model</span><span class="p">:</span> <span class="n">TeslaModel</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">model</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>SwiftUI实例， <code>LazyVGrid</code>中：</p><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">GridItem</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="kd">enum</span> <span class="nc">Size</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">adaptive</span><span class="p">(</span><span class="n">minimum</span><span class="p">:</span> <span class="n">CGFloat</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="p">.</span><span class="n">infinity</span><span class="p">)</span>
        <span class="k">case</span> <span class="n">fixed</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span>
        <span class="k">case</span> <span class="n">flexible</span><span class="p">(</span><span class="n">minimum</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">maximum</span><span class="p">:</span> <span class="n">CGFloat</span> <span class="p">=</span> <span class="p">.</span><span class="n">infinity</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ol>
<li><code>associated data</code>还能带默认值</li>
<li>核心作用是告诉系统griditem的size是采用哪种方案（枚举），顺便设置了这种方案下的参数。所以这种场景在swift下完全可以用枚举做到</li>
</ol>
<h1>Optionals</h1>
<p>可靠类型其实就是一个<code>Enum</code></p><div class="highlight"><pre><span></span><span class="kd">enum</span> <span class="nc">Optional</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span> <span class="c1">// a generic type, like Array&lt;Element&gt; or MemoryGame&lt;CardContent&gt; </span>
    <span class="k">case</span> <span class="kr">none</span>
    <span class="k">case</span> <span class="n">some</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="c1">// the some case has associated value of type T }</span>
</pre></div>
<p>它只有两个状态，要么是none，要么就是is set的状态，具体的值其实是绑定到了<code>associate data</code>里去了</p><p>所以你现在知道了有一种取法其实就是从<code>some</code>里面来取了。</p><h2>语法糖</h2>
<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="err">“</span><span class="n">hello</span><span class="err">”</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="kc">nil</span>
<span class="c1">// 其实是：</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">Optional</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="p">.</span><span class="kr">none</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">Optional</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="err">“</span><span class="n">hello</span><span class="err">”</span><span class="p">)</span>
<span class="kd">var</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">Optional</span><span class="p">&lt;</span><span class="nb">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="p">.</span><span class="kr">none</span>
</pre></div>
<p>使用：</p><div class="highlight"><pre><span></span><span class="kd">let</span> <span class="nv">hello</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="p">...</span>
<span class="bp">print</span><span class="p">(</span><span class="n">hello</span><span class="p">!)</span> 
<span class="c1">// 其实是：</span>
<span class="k">switch</span> <span class="n">hello</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="c1">// raise an exception (crash) </span>
    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">data</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="kd">let</span> <span class="nv">safehello</span> <span class="p">=</span> <span class="n">hello</span> <span class="p">{</span>
    <span class="bp">print</span><span class="p">(</span><span class="n">safehello</span><span class="p">)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// do something else</span>
<span class="p">}</span>
<span class="c1">// 其实是：</span>
<span class="k">switch</span> <span class="n">hello</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="p">{</span> <span class="c1">// do something else } </span>
    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">data</span><span class="p">):</span> <span class="bp">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 还有一种：</span>

<span class="kd">let</span> <span class="nv">x</span><span class="p">:</span> <span class="nb">String</span><span class="p">?</span> <span class="p">=</span> <span class="p">...</span>
<span class="kd">let</span> <span class="nv">y</span> <span class="p">=</span> <span class="n">x</span> <span class="p">??</span> <span class="err">“</span><span class="n">foo</span><span class="err">”</span>
<span class="c1">// 其实是：</span>
<span class="k">switch</span> <span class="n">x</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="n">y</span> <span class="p">=</span> <span class="err">“</span><span class="n">foo</span><span class="err">”</span>
    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">data</span><span class="p">):</span> <span class="n">y</span> <span class="p">=</span> <span class="n">data</span>
<span class="p">}</span>
</pre></div>
<ol>
<li>所以用<code>!</code>来解包是会报错的原理在此</li>
<li><code>guard</code>的原理同样是<code>switch</code></li>
<li>默认值的原理你应该也能猜到了</li>
<li>三个语法糖，对应的底层就是一句switch，其实就是<code>.none</code>时的三种处理方案</li>
</ol>
<p>当然，还可以<code>chain</code>起来
let x: String? = ...
let y = x?foo()?bar?.z</p><p>// 尝试还原一下：</p><div class="highlight"><pre><span></span><span class="k">switch</span> <span class="n">x</span> <span class="p">{</span>
    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="n">y</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">xval</span><span class="p">)::</span>
        <span class="k">switch</span> <span class="n">xval</span><span class="p">.</span><span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="n">y</span> <span class="p">=</span> <span class="kc">nil</span>
            <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">xfooval</span><span class="p">):</span>
                <span class="k">switch</span> <span class="n">xfooval</span><span class="p">.</span><span class="n">bar</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="p">.</span><span class="kr">none</span><span class="p">:</span> <span class="n">y</span> <span class="p">=</span> <span class="kc">nil</span>
                    <span class="k">case</span> <span class="p">.</span><span class="n">some</span><span class="p">(</span><span class="kd">let</span> <span class="nv">xfbarval</span><span class="p">):</span>
                        <span class="n">y</span> <span class="p">=</span> <span class="n">xfbarval</span><span class="p">.</span><span class="n">z</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>记住每一个句号对应一个switch，然后在<code>.none</code>的状态下安全退出就是<code>?</code>的用法了。</p><h1>@ViewBuilder</h1>
<ol>
<li>任意<code>func</code>或<code>只读的计算属性</code>都可以标识为<code>@ViewBuilder</code>，一旦标识，它里面的内容将会被解析为<code>a list of Views</code>（也仅仅是这个，最多再加上if-else来选择是“哪些view”，不能再定义变量和写其它代码了）<ul>
<li>一个典型例子就是View里面扣出来的代码(比如子view)做成方法，这个方法是需要加上@ViewBuilder的</li>
<li>或者改语法</li>
<li>或者只有一个View，就不会产生语法歧义，也是可以不加@ViewBuilder的</li>
</ul>
</li>
<li>所以不需要return，而如果你不打标，也是可以通过return来构建view的<ul>
<li>但是就不支持默认返回list或通过if-else返view list的语法了</li>
</ul>
</li>
<li><code>@ViewBuilder</code>也可以标识为方法的参数，表示需要接受一个返回views的函数</li>
</ol>
<div class="highlight"><pre><span></span><span class="kd">init</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="p">[</span><span class="n">Item</span><span class="p">],</span> <span class="p">@</span><span class="n">ViewBuilder</span> <span class="n">content</span><span class="p">:</span> <span class="p">@</span><span class="n">escaping</span> <span class="p">(</span><span class="n">Item</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">ItemView</span><span class="p">)</span> <span class="p">{...}</span>
</pre></div>
<p>同时也注意一下<code>@escaping</code>，凡是函数返回后才可能被调用的闭包（逃逸闭包）就需要，而我们的view是在需要的时候才创建，或反复移除并重建（重绘）的，显然符合逃逸闭包的特征。</p><blockquote>
<p>viewbuilder支持的控制流程代码指的是<code>if-else</code>和<code>ForEach</code>, 所以<code>for...in...</code>是不行的。</p></blockquote>
<h1>Protocol</h1>
<p>接口，协议，约束... 使用场景：</p><ul>
<li>用作类型(Type):<ul>
<li>func travelAround(using moveable: Moveable)</li>
<li>let foo = [Moveable]</li>
</ul>
</li>
<li>用作接口:<ul>
<li>struct cardView: View</li>
<li>class myGame: ObservableObject</li>
<li>behaviors: Identifiable, Hashable, ... Animatable</li>
</ul>
</li>
<li>用作约束：
  struct Game<Content> <code>where</code> Content: Equtable   // 类
  extension Array <code>where</code> Element: Hashable {...}  // 扩展
  init(data: Data) <code>where</code> Data: Collection, Data.Element: Identifiable // 方法</li>
<li>OC里的delegate</li>
<li>code sharing (by <code>extension</code>)<ul>
<li><code>extension</code> to a protocol</li>
<li>this is how Views get forecolor, font and all their other modifiers</li>
<li>also `firstIndex(where:) get implemented</li>
<li>an <code>extension</code> can add <em>default implementation</em> for a func or a var<ul>
<li>that's how <code>objectWillChange</code> comes from</li>
</ul>
</li>
<li><code>extension</code>可以作用到所有服从同一协议的对象<ul>
<li>func filter(_ isIncluded: (Element) -&gt; Bool) -&gt; Array<Element></li>
<li>只为<code>Sequence</code> protocol写了一份filter的扩展代码，但能作用于Array, Range, String, Dictionary</li>
<li>等一切conform to the <code>Sequence</code> protocol的类</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>SwiftUI的<code>View</code> protocol非常简单，conform 一个返回<code>some view</code>的<code>body</code>方法就行了，但是又为它写了无数<code>extension</code>，比如<code>foregroundColor</code>, <code>padding</code>, etc. 示意图：</p><figure  style="flex: 146.20253164556962" ><img width="924" height="316" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/9bfb49031e316c1d1d1bc4a5d6b57427.png" alt=""/></figure><h2>Generics(泛型)</h2>
<p>举例：</p><div class="highlight"><pre><span></span><span class="kd">protocol</span> <span class="nc">Identifiable</span> <span class="p">{</span>
    <span class="kd">associatedtype</span> <span class="n">ID</span><span class="p">:</span> <span class="nb">Hashable</span>
    <span class="kd">var</span> <span class="nv">id</span><span class="p">:</span> <span class="n">ID</span> <span class="p">{</span> <span class="kr">get</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<ol>
<li>不像struct，protocol并不是用<code>Identifiable&lt;ID&gt;</code>来表示泛型，而是在作用域内定义</li>
<li>上例中，ID既定义了类别别名，还规范了约束</li>
</ol>
<ul>
<li>所以你Identifiable的类, 是需要有一个Hashable的ID的</li>
<li>而Hashable的对象，又是需要Equatable的(因为hash会碰撞出相同的结果，需要提供检查相等的方法)</li>
<li>-&gt; <code>protocol inheritancee</code></li>
</ul>
<h1>Shape</h1>
<ul>
<li>Shape is a <code>protocol</code> that inherits from <code>View</code>.</li>
<li>In other words, all Shapes are also Views.</li>
<li>Examples of Shapes already in SwiftUI: RoundedRectangle, Circle, Capsule, etc.</li>
<li>by default, Shapes draw themselfs by <code>filling</code> with the current foreground color.</li>
</ul>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nf">fill</span><span class="p">&lt;</span><span class="n">S</span><span class="p">&gt;(</span><span class="kc">_</span> <span class="n">whatToFillWith</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">some</span> <span class="n">view</span> <span class="k">where</span> <span class="n">S</span><span class="p">:</span> <span class="n">ShapeStyle</span>
</pre></div>
<p><code>ShapeStyle</code> protocol turns a <code>Shape</code> into a <code>View</code>: Color, ImagePaint, AngularGradinet, LinearGradient</p><p>自定义shape最好用path(系统的已经通过extension实现好了view的body)：</p><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nf">path</span><span class="p">(</span><span class="k">in</span> <span class="n">rect</span><span class="p">:</span> <span class="n">CGRect</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Path</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span> <span class="n">Path</span> 
<span class="p">}</span>
</pre></div>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/cs193p_2021_%E7%AC%94%E8%AE%B0%5B1%5D/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%EF%BC%88Hungarian-Algorithm%EF%BC%89/" target="_self">一张图说清匈牙利算法（Hungarian-Algorithm）</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%EF%BC%88Hungarian-Algorithm%EF%BC%89/" target="_self">
                <time class="text-uppercase">
                    October 23 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><p>做多目标跟踪的时候会碰到这个算法，每个人都有自己的说法讲清楚这个算法是干什么的？我的老师就跟我说过是什么给工人分配活干（即理解为<code>指派问题</code>），网上还看到有说红娘尽可能匹配多的情侣等，透过这些感性理解，基本上就能理解大概是最大匹配的问题了。</p><p>然后加了限制：后来者优先。即后匹配的<strong>能</strong>抢掉前人已匹配的对象，这个是有数学依据还是只是一种实现思路我就没深究了。</p><p>我的理解不会比别人更高级，之所以能用一张图说清楚，只不过是我作图的时候发现可以把过程画在一张图里，只需要把图示标清楚就好了，这样就不需要每一步画一张图了，一旦理解了，哪怕忘了，一瞅这张图也能立刻回忆起来。</p><p>先上数据：</p><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">relationship_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</pre></div>
<p>你可以理解为6个工人，7个工作，6个男孩，7个女孩等，当然，6行7列，这么直观理解也是一点问题都没有的。</p><p>算法匹配过程如下：
<figure class="vertical-figure" style="flex: 38.028169014084504" ><img width="648" height="852" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/cf127d2b3fa84eb6c94999802507f38f.png" alt=""/></figure></p><ul>
<li>灰蓝线就是被抢掉的</li>
<li>绿线就是抢夺失败的</li>
<li><code>紫线</code>是被抢了后找候选成功的</li>
<li><code>红线</code>是一次性成功的</li>
</ul>
<p>其中被抢的和抢夺失败的还加了删除线，这是为了强调。匹配成功的就是<code>红线</code>和<code>紫线</code>，也就是说，我们匹配出来的是：</p><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
<p>甚至可以这么表示这个过程：</p>
<pre><code>x0,y0
x1,y1
x2,y0 -&gt; x0,y1 -&gt; x1-&gt;y4 (x2抢x0的,x0抢x1的)
x3,y2
x4,y3
x5,y3 -&gt; x4匹配不到新的，抢夺失败，-&gt; x5,null
</code></pre>
<p>有没有说清楚？就两步：</p><ol>
<li>根据关联表直接建立关系</li>
<li>如果当前<code>C</code>匹配的对象已经被<code>B</code>匹配过了，那么尝试把它抢过来：</li>
</ol>
<ul>
<li><code>B</code>去找别的匹配<ul>
<li>找到了(<code>A</code>)就建立新的匹配<ul>
<li>如果新的匹配(<code>A</code>)也已经被别人(<code>D</code>)匹配了，那么那个“别人(<code>D</code>)”也放弃当前匹配去找别的（<em>递归警告</em>）</li>
</ul>
</li>
<li>如果找不到新的匹配，那么<code>C</code>抢夺失败，递归中的<code>D</code>也同理，失败向上冒泡</li>
</ul>
</li>
</ul>
<p>注意递归怎么写代码就能写出来了：</p><div class="highlight"><pre><span></span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">relationship_matrix</span><span class="o">.</span><span class="n">shape</span>    <span class="c1"># 6个x，7个y</span>

<span class="c1"># 如果x0与y0关联，x3也与y0关联，那么x0去找新的匹配时，需要把y0过滤掉</span>
<span class="c1"># 同理x0如果找到下一个y2，y2已被x2关联，那么x2找新的匹配时[y0, y2]都需要过滤掉</span>
<span class="c1"># 我们把这个数组存为y_used</span>
<span class="n">y_used</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ny</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>  <span class="c1"># 存y是否连接上</span>
<span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ny</span><span class="p">,),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># 存x连接的对象，没有为-1</span>

<span class="k">def</span> <span class="nf">find_other_path_and_used</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">relationship_matrix</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">y_used</span><span class="p">[</span><span class="n">y</span><span class="p">]:</span>
            <span class="n">y_used</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>        <span class="c1"># 处于争夺中的y，需要打标，在后续的递归时要过滤掉</span>
            <span class="k">if</span> <span class="n">path</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">find_other_path_and_used</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">y</span><span class="p">]):</span>
                <span class="n">path</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>         <span class="c1"># 直接连接 和 抢夺成功</span>
                <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>                    <span class="c1"># 抢夺失败 和 默认失败</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
    <span class="n">y_used</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># empty</span>
    <span class="n">find_other_path_and_used</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
<p>真的写代码实现的时候，难点反而是<code>y_used</code>这个，第一遍代码没考虑这一点，导致递归的时候每次都从$y_0$开始而出现死循环，意识到后把处于争抢状态中的<code>y</code>打个标就好了。</p><p>scipy中有一个算法实现了Hungarian algorithm：</p><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">linear_sum_assignment</span>

<span class="c1"># relationship_matrix是代价矩阵</span>
<span class="c1"># 所以我们要代价越小越好，就用1来减</span>
<span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">relationship_matrix</span><span class="p">)</span> 
<span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
</pre></div>

<pre><code>[(0, 0), (1, 1), (2, 6), (3, 2), (4, 3), (5, 4)]
</code></pre>
<p>为什么与上面不一样呢？</p><ol>
<li>（0，0），（1，1）的匹配显然不是我们实现的后来者优先</li>
<li>他把行看成是工人，列看成是任务，每个工人总要分配个任务，所以(5,4)这种代价矩阵里没有的关联它也做出来了，目的只是让“总代价”最小</li>
</ol>

<pre><code>(1-relationship_matrix)[rows, cols]  # 总代价为1
</code></pre>

<pre><code>array([0, 0, 0, 0, 0, 1])
</code></pre>
<p>从它的名字也能看出来，它是理解为<code>指派问题</code>的(<code>assignment</code>)</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E4%B8%80%E5%BC%A0%E5%9B%BE%E8%AF%B4%E6%B8%85%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95%EF%BC%88Hungarian-Algorithm%EF%BC%89/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%9D%8E%E5%AE%8F%E6%AF%85MACHINE-LEARNING-2021-SPRING%E7%AC%94%E8%AE%B0-4/" target="_self">李宏毅MACHINE LEARNING 2021 SPRING笔记[4]</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%9D%8E%E5%AE%8F%E6%AF%85MACHINE-LEARNING-2021-SPRING%E7%AC%94%E8%AE%B0-4/" target="_self">
                <time class="text-uppercase">
                    October 15 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Adversarial Attack</h1>
<p>给你一张猫的图片，里面加入少许噪音，以保证肉眼看不出来有噪音的存在：</p><ol>
<li>期望分类器认为它不是猫</li>
<li>期望分类器认为它是一条鱼，一个键盘...</li>
</ol>
<p>比如你想要欺骗垃圾邮件过滤器</p><ul>
<li>找到一个与$x^0$非常近的向量x</li>
<li>网络正常输出y</li>
<li>真值为$\hat y$</li>
<li>$L(x) = -e(y, \hat y)$</li>
<li>$x^* = arg\underset{d(x^0, x) \leq \epsilon}{\rm min}\ L(x)$ 即要找到令损失最大的x<ol>
<li>这里L(x)我们取了反</li>
<li>$\epsilon$越小越好，指的是$x^0$要与x越接近越好（欺骗人眼）</li>
</ol>
</li>
<li>如果还期望它认成是$y^{target}$，那就再加上与其的的损失</li>
<li>$L(x) = -e(y, \hat y) + e(y, y^{target})$</li>
<li>注意两个error是反的，一个要求越远越好(真值），一个要求越近越好（target)</li>
</ul>
<p>怎么计算$d(x^0, x) \leq \epsilon$呢？</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/52ea0aa0520c35787d94019e0efc61a7.png" alt=""/></figure><p>图上可知，如果都改变一点点，和某一个区域改动相当大，可能在L2-norm的方式计算出来是一样的，但是在L-infinity看来是不一样的（它只关心最大的变动）。</p><p>显然L-infinity更适合人眼的逻辑，全部一起微调人眼不能察觉，单单某一块大调，人眼是肯定可以看出来的。</p><p>而如果是语音的话，可能耳朵对突然某个声音的变化反而不敏感，整体语音风格变了却能立刻认出说话的人声音变了，这就要改变方案了。</p><h2>Attack Approach</h2>
<p>如何得到这个x呢？其实就是上面的损失函数。以前我们是为了train权重，现在train的就是x本身了。</p><ol>
<li>损失达到我们的要求 （有可能这时候与原x相关很远）</li>
<li>与原x的距离达到我们的要求, 怎么做？<ul>
<li>其实就是以$x^0$为中心，边长为$2\epsilon$的矩形才是期望区域</li>
<li>如果update后，$x^t$仍然落在矩形外，那么就在矩形里找一个离它最近的点，当作本轮更新后的$x^t$，进入下一轮迭代</li>
</ul>
</li>
</ol>
<p>Fast Gradient Sign Method(FGSM): <a href="https://arxiv.org/abs/1412.6572">https://arxiv.org/abs/1412.6572</a></p><ul>
<li>相比上面的迭代方法，FGSM只做一次更新</li>
<li>就是根据梯度，判断是正还是负，然后把原x进行一次加减$\epsilon$的操作（其实等于是落在了矩形的四个点上）</li>
<li>也就是说它直接取了四个点之一作为$x^0$</li>
</ul>
<h2>White Box v.s. Black Box</h2>
<p>讲上述方法的时候肯定都在疑惑，分类器是别人的，我怎么可能拿到别人的模型来训练我的攻击器？ -&gt; <strong>White Box Attack</strong></p><p>那么<code>Black Box Attack</code>是怎么实现的呢？</p><ol>
<li>如果我们知道对方的模型是用什么数据训练的话，我们也可以训练一个类似的(proxy network)<ul>
<li>很大概率都是用公开数据集训练的</li>
</ul>
</li>
<li>如果不知道的话呢？就只能尝试地丢一些数据进去，观察（记录）它的输出，然后再用这些测试的输入输出来训练自己的proxy network了。</li>
</ol>
<ul>
<li>one pixel attack<ul>
<li><a href="https://arxiv.org/abs/1710.08864">https://arxiv.org/abs/1710.08864</a></li>
<li><a href="https://youtu.be/tfpKIZIWidA">https://youtu.be/tfpKIZIWidA</a></li>
</ul>
</li>
<li>universal adversarial attack<ul>
<li>万能noise</li>
<li><a href="https://arxiv.org/abs/1610.08401">https://arxiv.org/abs/1610.08401</a></li>
</ul>
</li>
<li>声音</li>
<li>文本</li>
<li>物理世界<ul>
<li>比如欺骗人脸识别系统，去认成另一个人</li>
<li>又比如道路环境，车牌识别等，也可以被攻击</li>
<li>要考虑摄像头能识别的分辨率</li>
<li>要考虑训练时候用的图片颜色与真实世界颜色不一致的问题</li>
</ul>
</li>
<li>Adversarial Reprogramming</li>
<li>Backdoor in Model<ul>
<li>attack happens at the training phase</li>
<li><a href="https://arxiv.org/abs/1804.00792">https://arxiv.org/abs/1804.00792</a></li>
<li>be careful of unknown dataset...</li>
</ul>
</li>
</ul>
<h2>Defence</h2>
<h3>Passive Defense（被动防御）</h3>
<p>进入network前加一层filter</p><ul>
<li>稍微模糊化一点，就去除掉精心设计的noise了<ul>
<li>但是同时也影响了正常的图像</li>
</ul>
</li>
<li>对原图进行压缩</li>
<li>把输入用Generator重新生成一遍</li>
</ul>
<p>如果攻击都知道你怎么做了，其实很好破解，就把你的filter当作network的一部分重新开始设计noise，所以可以选择加入随机选择的一些预处理(让攻击者不可能针对性地训练)：</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/c5baa988904325835254f3ac7a7ee4e1.png" alt=""/></figure><h3>Proactive Defense（主动防御）</h3>
<p>训练的时候就训练比较不容易被攻破的模型。比如训练过程中加入noise，把生成的结果重新标注回真值。</p><ul>
<li>training model</li>
<li>find the problem</li>
<li>fix it</li>
</ul>
<p>有点类似于<code>Data Augmentation</code></p><p>仍然阻挡不了新的攻击算法，即你对数据进行augment之外的范围。</p><h1>Explainable Machine Learning(可解释性)</h1>
<ul>
<li>correct answers $\neq$ intelligent</li>
<li>很多行业会要求结果必须可解释<ul>
<li>银行，医药，法律，驾驶....</li>
</ul>
</li>
</ul>
<p><strong>Local Explanation</strong></p><p>Why do you thing <strong>this image</strong> is a cat?</p><p><strong>Global Explanation</strong></p><p>What does a &quot;<strong>cat</strong>&quot; look like?</p><ol>
<li>遮挡或改变输入的某些部分，观察对已知输出的影响<ul>
<li>（比如拦到某些部分确实认不出图像是一条狗了）</li>
</ul>
</li>
<li>遮挡或改变输入的某些部分，把两种输出做loss，对比输入变化与loss变化：<ul>
<li>$|\frac{\varDelta e}{\varDelta x}| \rightarrow \frac{\partial e}{\partial x_n}$</li>
</ul>
</li>
</ol>
<p>把上述（任一种）每个部分（像素，单词）的影响结果输出，就是：<code>Saliency Map</code></p><h2>Saliency Map</h2>
<figure  style="flex: 271.9298245614035" ><img width="1240" height="228" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/fdcce76fc7337b0ee787724913f998f0.png" alt=""/></figure><p>图1，2就是为了分辨宝可梦和数码宝贝，人类一般很难区分出来，但机器居然轻松达到了98%的准确率，经过绘制<code>Saliency Map</code>，发现居然就是图片素材（格式）的原因，一个是png，一个是jpg，造成背景一个是透明一个是不透明的。</p><p>也就是说，能发现机器判断的依据不是我们关注的本体（高亮部分就是影响最大的部分，期望是在动物身上）</p><p>第三张图更可笑，机器是如何判断这是一只马的？居然也不是马的本体，而是左下角，标识图片出处的文字，可能是训练过程中同样的logo过多，造成了这个“人为特征”。</p><p>解决方案：</p><h3>Smooth Gradient</h3>
<p>随机给输入图片加入噪点，得到saliency map（们），然后取平均</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e672962530cdb4c88d616b3fa82f73f8.png" alt=""/></figure><h3>Integrated gradient(IG)</h3>
<p>一个特征在从无到有的阶段，梯度还是明显的，但是到了一定程度，特征再增强，对gradient影响也不大了，比如从片子来判断大象，到了一定长度，一张图也不会“更像大象”</p><p>一种思路：<a href="https://arxiv.org/abs/1611.02639">https://arxiv.org/abs/1611.02639</a></p><h2>global explaination</h2>
<p><strong>What does a filter detect?</strong></p><p>如果经过某层（训练好的）filter，得到的feature map一些位置的值特别大，那说明这个filter提取的就是这类特征/patten。</p><p>我们去&quot;创造&quot;一张包含了这种patten的图片：$X^* = arg\ \underset{X}{\rm max}\sum_i\sum_j a_{ij}$，即这个图片是“训练/learn“出来的，通过找让X的每个元素($a_{ij}$)在被filter乘加后结果最大的方式。 -&gt; <code>gradient ascent</code></p><p>然后再去观察$X^*$有什么特征，就基本上可以认定这个（训练好的）filter提取的是什么样的patten了。
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/33b78193d5c74e4d146b9efab631c932.png" alt=""/></figure></p><blockquote>
<p><code>adversarial attack</code> 类似的原理，但这是对单filter而言。如果你想用同样的思路去让输出y越大越好，得到X，看X是什么，得到的X大概率都是一堆噪音。如果能生成图像，那是<code>GAN</code>的范畴了。</p></blockquote>
<p>于是，尝试再加一个限制，即不但要让y最大，还要让X看起来最有可能像一个数字：</p><ul>
<li>$R(X)$: how likely X is a digit</li>
<li>$X^* = arg\ \underset{X}{\rm max}y_i + \color{red}{R(X)}$</li>
<li>$R(X) = -\sum_{i,j}|X_{i,j}|$ 比如这个规则，期望每个像素越黑越好</li>
</ul>
<h1>Domain Adaptation</h1>
<p><code>Transfer Learning</code>的一种，在训练数据集和实际使用的数据集不一样的时候。 <a href="https://youtu.be/qD6iD4TFsdQ">https://youtu.be/qD6iD4TFsdQ</a></p><p>需要你对<code>target domain</code>的数据集有一定的了解。</p><p>有一种比较好的情况就是，target domain既有数据，还有标注（但不是太多，如果太多的话就不需要<code>source domain</code>了，直接用target来训练就好了），那就像bert一样，去<code>fine tune</code>结果，要注意的是标本量过小，可能很容易<code>overfitting</code>.</p><p>如果target doamin有<strong>大量</strong>资料，但是没有标注呢？</p><h2>Domain Adversarial Training</h2>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/7b419953f55daf61a0a4d3f2e77b156d.png" alt=""/></figure><ul>
<li>把source domain的network分为特征提取器（取多少层cnn可以视为超参，并不一定要取所有层cnn）和分类器</li>
<li>然后在特征取层之后跟另一个分类器，用来判断图像来自于source还是target（有点像<code>Discriminator</code></li>
<li>与真值有一个loss，source, target之间也有一个loss，要求找到这样的参数组分别让两个loss最小</li>
<li>loos和也应该最小（图中用的是减，但其实$L_d$的期望是趋近于0，不管是正还是负都是期望越小越好）（不如加个绝对值？）</li>
<li>每一小块都有一组参数，是一起训练的</li>
<li>目的就是既要逼近训练集的真值，还要训练出一个网络能模糊掉source和target数据集的差别</li>
</ul>
<h3>Limit</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/1c785d92413a44f14ca579564bd3a107.png" alt=""/></figure><p>如果target数据集如上图左，显然结果是会比上图右要差一点的，也就是说尽量要保持同分布。在这里用了另一个角度，就是让数据<strong>离boundary越远越好</strong></p><ul>
<li>Decision-boundary Iterative Refinement Training with a Teacher(<code>DIRT-T</code>)<ul>
<li><a href="https://arxiv.org/abs/1802.08735">https://arxiv.org/abs/1802.08735</a></li>
</ul>
</li>
<li>Maximum Classifier Discrepancy <a href="https://arxiv.org/abs/1712.02560">https://arxiv.org/abs/1712.02560</a></li>
</ul>
<h2>More</h2>
<ul>
<li>如果source 和 target 里的类别不完全一样呢？<ul>
<li>Universal domain adaptation</li>
</ul>
</li>
<li>如果target既没有label，数据量也非常少（比如就一张）呢？<ul>
<li>Test Time Training(TTT) <a href="https://arxiv.org/abs/1909.13231">https://arxiv.org/abs/1909.13231</a></li>
</ul>
</li>
</ul>
<p><strong>Domain Generalization</strong>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/029818e3d225d57c9b9a866b569983b5.png" alt=""/></figure></p><h1>Deep Reinforcement Learning (RL)</h1>
<ul>
<li><strong>Environment</strong> 给你 <code>Observation</code></li>
<li><strong>Actor</strong> 接收入 <code>Observation</code>, 输出 <code>Action</code></li>
<li><code>Action</code> 反馈给 <strong>Environment</strong>, 计算出 <code>Reward</code> 反馈给 <strong>Actor</strong></li>
<li>要求 <code>Reward</code> 最大</li>
</ul>
<p>与 GAN 的不同之处，不管是生成器还是判别器，都是一个network，而RL里面，Actor和Reward都是黑盒子，你只能看到结果。</p><h2>Policy Gradient</h2>
<p><a href="https://youtu.be/W8XF3ME8G2I">https://youtu.be/W8XF3ME8G2I</a></p><ol>
<li>先是用很类似监督学习的思路，给每一步的最优（或最差）方案一个label，有label就能做loss。先把它变成一个二分类的问题。</li>
<li>打分还可以不仅仅是“好”或“不好”，还可以是一个程度，比如1.5比0.5的“支持”力度要大一些，而-10显然意味着你千万不要这么做，非常拒绝。</li>
<li>比如某一步，可以有三种走法，可以用onehot来表示，其中一种走法可以是[1,0,0]$^T$，表示期望的走法是第一种。</li>
<li>但是也可以是[-1,0,0]$^T$，标识这种走法是不建议的</li>
<li>也可以是[3.5,0,0]$^T$等</li>
<li>后面会用<code>1, -1, 10, 3.5</code>这样的scalar来表示，但要记住其实它们是ont-hot中的那个非零数。</li>
</ol>
<p>现实世界中很多场景不可能执行完一步后就获得reward，或者是全局最佳的reward（比如下围棋）。</p><p><strong>v1</strong></p><p>一种思路是，每一步之后，把游戏/棋局进行完，把当前reward和后续所有步骤的reward加一起做reward -&gt; <code>cumulated reward</code> $\rightarrow G_t = \sum_{n=t}^Nr_n$</p><p><strong>v2</strong></p><p>这种思路仍然有问题，游戏步骤越长，当前步对最终步的影响越小。因此引入一个小于1的权重$\gamma &lt; 1$: $G_1' = r_1 + \gamma r_2 + \gamma^2r_3 + \cdots$</p><p>这样越远的权重越小： $G_t' = \sum_{n=t}^N \color{red}{\gamma^{n-t}} r_n$</p><blockquote>
<p>注意，目前得到的<code>G</code>就是为了给每一次对observation进行的action做loss的对象。</p></blockquote>
<p><strong>v3</strong></p><p>标准化reward。你有10分，是高是低？如果所有人都是20分，那就是低分，所以与G做对比的时候，通常要减去一个合适的值<code>b</code>，让得分的分布有正有负。</p><p><strong>Policy Gradient</strong></p><p>普通的gradient descent是搜集一遍数据，就可以跑for循环了，而PG不行，你每次得到梯度后，要重采一遍样，其实也很好理解，你下了某一步，经过后续50步后，输了，你的下一轮测试应该是下一盘随机的棋，而不是把更新好的参数再用到同一盘棋去。</p><p>还是不怎么好理解，至少要知道，我做参数是不为了训练出这一盘棋是怎么下出来的，而是根据这个（大多是输了的）结果，以及学到的梯度，去下一盘新的棋试试。</p><h2>Actor Critic</h2>
<p><strong>Critic</strong>:</p><ul>
<li>Given <code>actor</code> $\theta$, how good it is when <code>observing</code> s (and taking action a)</li>
</ul>
<p><strong>Value function</strong> $V^\theta(s)$:</p><ul>
<li>使用actor $\theta$的时候，预测会得到多少的<code>cumulated reward</code></li>
<li>分高分低其实还是取决于actor，同样的局面，不同的actor肯定拿的分不同。</li>
</ul>
<h3>Monte-Carlo based approach (MC)</h3>
<p>蒙特卡洛搜索，正常把游戏玩完，得到相应的G.</p><h3>Temporal-difference approach (TD)</h3>
<p>不用玩完整个游戏，就用前后时间段的数据来得到输出。
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/de79fef0ebceeda7cd5011e38ab28c46.png" alt=""/></figure></p><p>关键词：</p><ul>
<li>我们既不知道v(t+1)，也不知道v(t)，但确实能知道<code>v(t+1)-v(t)</code>.</li>
</ul>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/1fbf32aed94a0b3f47d9b124a466874c.png" alt=""/></figure><p>这个例子没看懂，后面七次游戏为什么没有sa了？</p><p><strong>v3.5</strong></p><p>上文提到的V可以用来作更早提到的b:</p><ul>
<li>${S_t, a_t}\ A_t = G_t' - V^\theta(S_t)$</li>
<li>回顾一下，$V^\theta(S_t)$是看到某个游戏画面时算出来的reward</li>
<li>它包含$S_t$状态下，后续各种步骤的reward的平均值</li>
<li>而$G_t'$则是这一步下的rewared</li>
<li>两个数相减其实就是看你的这一步是比平均水平好还是差</li>
<li>比如你得到了个负值，代表在当前场景下，这个actor执行的步骤是低于平均胜率的，需要换一种走法。</li>
</ul>
<p><strong>v4</strong></p><p>3.5版下，G只有一个样本（一次游戏）的结果，这个版本里，把st再走一步，试难$S_{t+1}$的各种走法下reward的平均值，用它来替换G'，而它的值，就是当前的reward加上t+1时刻的V:</p><ul>
<li>$r_t + V^\theta(S_{t+1}) - V^\theta(S_t)$</li>
</ul>
<p>这就是：</p><h3>Advantage Actor-Critic</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a038f8d6237e4d33a943099bdbfdefc3.png" alt=""/></figure><p>就看图而言，感觉就是坚持这一步走完，后续所有可能的rewawrd， 减去， 从这一步开始就试验所有走法的reward</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/82541f55c2db06d3b1e8339d6e63d140.png" alt=""/></figure><p>More:</p><p>Deep Q Network (DQN)</p><ul>
<li><a href="https://arxiv.org/abs/1710.02298">https://arxiv.org/abs/1710.02298</a></li>
<li><a href="https://youtu.be/o_g9JUMw1Oc">https://youtu.be/o_g9JUMw1Oc</a></li>
<li><a href="https://youtu.be/2-zGCx4iv_k">https://youtu.be/2-zGCx4iv_k</a></li>
</ul>
<h2>Reward Shaping</h2>
<p>前面说过很多场景要得到reward非常困难（时间长，步骤长，或根本不会结束），这样的情况叫<code>sparse reward</code>，人类可以利用一些已知知识去人为设置一些reward以增强或削弱机器的某些行为。</p><p>比如游戏：</p><ol>
<li>原地不动一直慢慢减分</li>
<li>每多活一秒也慢慢减分（迫使你去获得更高的reward, 避免学到根本就不去战斗的方式）</li>
<li>每掉一次血也减分</li>
<li>每杀一个敌人就加分</li>
<li>以此类推，这样就不至于要等到一场比赛结束才有“一个”reward</li>
</ol>
<p>又比如训练机械手把一块有洞的木板套到一根棍子上：</p><ol>
<li>离棍子越近，就有一定的加分</li>
<li>其它有助于套进去的规则</li>
</ol>
<p>还可以给机器加上<strong>好奇心</strong>，让机器看到有用的“新的东西”也加分。</p><h2>No Reward, learn from demostration</h2>
<p>只有游戏场景才会有明确的reward，大多数现实场景都是没有reward的，比如训练自动驾驶的车，或者太过死板的reward既不能适应变化，也容易被打出漏洞，比如机器人三定律里，机器人不能伤害人类，却没有禁止囚禁人类，又比如摆放盘子，却没有给出力度，等盘子摔碎了，再去补一条𢱨碎盘子就负reward的规则，也晚了，由此引入模仿学习：</p><h3>Imitation Learning</h3>
<p>略</p><h1>Life-Long Learning</h1>
<p>持续学习，机器学习到一个模型后，继续学下一个模型（任务）。</p><ol>
<li>为什么不一个任务学一个模型<ul>
<li>不可能去存储所有的模型</li>
<li>一个任务的知识不能转移到另一个任务</li>
</ul>
</li>
<li>为什么不直接用迁移学习（迁移学习只关注迁移后的新任务）</li>
</ol>
<h2>Research Directions</h2>
<h3>Selective Synaptic Plasticity</h3>
<p>选择性的神经突触的可塑性？（Regularization-based Approach）</p><p><strong>Catastrophic Forgetting</strong> 灾难性的遗忘
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/207da40b7ff67f6534e5fc5de208cce9.png" alt=""/></figure></p><p>在任务1上学到的参数，到任务2里接着训练，顺着梯度到了任务2的最优参数，显然不再是任务1的做以参，这叫灾难性的遗忘</p><p>一种思路：</p><p>任务2里梯度要更新未必要往中心，也可以往中下方，这样既在任务2的低loss区域，也没有跑出任务1的低loss区域，实现的方式是找到对之前任务影响比较小的参数，主要去更新那些参数。比如上图中，显然$\theta_1$对任务1的loss影响越小，但是更新它之后会显著影响任务2的loss，而$\theta_2$的改动才是造成任务1loss变大的元凶。</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/1b27e4cf8478e749d8899d30b75bbb22.png" alt=""/></figure><p>Elastic Weight Consolidation(EWC)</p><ul>
<li><a href="https://arxiv.org/abs/1612.00796">https://arxiv.org/abs/1612.00796</a></li>
</ul>
<p>Synaptic Intelligence(SI)</p><ul>
<li><a href="https://arxiv.org/abs/1703.04200">https://arxiv.org/abs/1703.04200</a></li>
</ul>
<p>Memory Aware Synapses(MAS)</p><ul>
<li><a href="https://arxiv.org/abs/1711.09601">https://arxiv.org/abs/1711.09601</a></li>
</ul>
<p>RWalk</p><ul>
<li><a href="https://arxiv.org/abs/1801.10112">https://arxiv.org/abs/1801.10112</a></li>
</ul>
<p>Sliced Cramer Preservation(SCP)</p><ul>
<li><a href="https://openreview.net/forum?id=BJge3TNKwH">https://openreview.net/forum?id=BJge3TNKwH</a></li>
</ul>
<figure  style="flex: 132.76231263383298" ><img width="1240" height="467" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/474bbac22bf3778191de7bf09d10d69d.png" alt=""/></figure><h3>Memory Reply</h3>
<ol>
<li>在训练task1的时候，同时训练一个相应的generator</li>
<li>训练task2的时候，用task1的generator生成pseudo-data，一起来训练生成新的model</li>
<li>同时也训练出一个task1&amp;2的generator</li>
<li>...</li>
</ol>
<h1>Network Compress</h1>
<h2>pruning (剪枝)</h2>
<p>Networks ar typically over-parameterized (there is significant redundant weights or neurons)</p><ul>
<li>可以看哪些参数通常比较大，或值的变化不影响loss（梯度小）-&gt; 权重，为0的次数少 -&gt; 神经元 等等</li>
<li>剪枝后精度肯定是会下降的</li>
<li>需要接着fine-tune</li>
<li>一次不要prune to much</li>
<li>剪参数和剪神经元效果是不一样的<ul>
<li>剪参数会影响矩阵运算，继而影响GPU加速</li>
</ul>
</li>
</ul>
<p>那么为什么不直接train一个小的network呢？</p><ul>
<li>小的network通常很难train到同样的准确率。 （大乐透假说）</li>
</ul>
<h2>Knowledge Distillation (知识蒸馏)</h2>
<p>老师模型训练出来的结果，用学生模型（小模型）去模拟（即是模拟整个输出，而不是模拟分类结果），让小模型能达到大模型同样的结果。</p><p>一般还会在输出的softmax里面加上温度参数（即平滑输出，不同大小的数除一个大于1的数，显然越大被缩小的倍数也越大，比如100/10=10，少了90，10/10=1, 只少了9，差别也从90变成了9）(或者兴趣个极端的例子，T取无穷大，那么每个输出就基本相等了)</p><h2>Parameter Quantization</h2>
<ol>
<li>Using less bits to represent a value</li>
<li>Weight clustering<ul>
<li>把weights分成预先确定好的簇（或根据分布来确定）</li>
<li>对每簇取均值，用均值代替整个簇里所有的值</li>
</ul>
</li>
<li>represent frequent clusters by less bits, represent rare clusters by more bits<ul>
<li>Huffman encoding</li>
</ul>
</li>
</ol>
<p>极限，<code>Binary Weights</code>，用两个bits来描述整个网络，扩展阅读。</p><h2>Depthwise Separable Convolution</h2>
<p>回顾下CNN的机制，参数量是：</p><ul>
<li>卷积核的大小 x 输入图像的通道数 x 输出的通道数</li>
<li>($k\times k$) x in_channel x out_channel</li>
</ul>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/769ea8db15464e205b9c674747eb650d.png" alt=""/></figure><p>而<code>Depthwise Separable Convolution</code>由两个卷积组成：</p><ol>
<li>Depthwise Convolution<ul>
<li>很多人对CNN的误解刚好就是Depthwise Convolution的样子，即一个卷积核对应一个输入的channel（事实上是一组卷积核对应所有的输入channel）</li>
<li>因此它的参数个数 k x k x in_channel</li>
</ul>
</li>
<li>PointWise Convolution<ul>
<li>这里是为了补上通道与通道这间的关系</li>
<li>于是用了一个1x1的<code>标准</code>卷积（即每一组卷积核对应输入的所有通道）</li>
<li>输出channel也由这次卷积决定</li>
<li>应用标准卷积参数量：(1x1) x in_channel x out_channel</li>
</ul>
</li>
</ol>
<figure  style="flex: 130.52631578947367" ><img width="1240" height="475" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e147af5889954aa781498c5977f659f1.png" alt=""/></figure><p>两个参数量做对比, 设<code>in_channel = I</code>, <code>out_channel = O</code></p><ol>
<li>$p_1 = (k\times k) \times I \times O$</li>
<li>$p_2 = (k\times k) \times I + (1\times 1) \times I \times O = (k\times k) \times I + I \times O$</li>
<li>$\frac{p_2}{p_1} = \frac{I\cdot(k^2 + O)}{I\cdot{k^2\cdot O}}</li>
</ol>
<p>= \frac{1}{O} + \frac{1}{k^2} \approx \frac{1}{k^2} 
$</p><p>O代表out_channel，大型网络里256，512比比皆是，所以它可以忽略，那么前后参数量就由$k^2$决定了，如果是大小为3的卷积核，参数量就变成1/9了，已经是压缩得很可观了。</p><h3>Low rank approximation</h3>
<p>上面是应用，原理就是<code>Low rank approximation</code></p><p>以全连接网络举例</p><ol>
<li>如果一个一层的网络，输入<code>N</code>， 输出<code>M</code>，参数为<code>W</code>，那么参数量是<code>MxN</code></li>
<li>中间插入一个线性层<code>K</code>，<ul>
<li>参数变成：<code>V</code>:N-&gt;K, <code>U</code>:K-&gt;M,</li>
<li>参数量：<code>NxK</code> + <code>KxM</code></li>
</ul>
</li>
<li>只要K远小于M和N（比如数量级都不一致），那么参数量是比直接MxN要小很多的</li>
<li>这也限制了能够学习的参数的可能性（毕竟原始参数量怎么取都行）<ul>
<li>所以叫<code>Low rank</code> approximation</li>
</ul>
</li>
</ol>
<p><strong>to learn more</strong></p><p>SqueezeNet</p><ul>
<li><a href="https://arxiv.org/abs/1602.07360">https://arxiv.org/abs/1602.07360</a></li>
</ul>
<p>MobileNet</p><ul>
<li><a href="https://arxiv.org/abs/1704.04861">https://arxiv.org/abs/1704.04861</a></li>
</ul>
<p>ShuffleNet</p><ul>
<li><a href="https://arxiv.org/abs/1707.01083">https://arxiv.org/abs/1707.01083</a></li>
</ul>
<p>Xception</p><ul>
<li><a href="https://arxiv.org/abs/1610.02357">https://arxiv.org/abs/1610.02357</a></li>
</ul>
<p>GhostNet</p><ul>
<li><a href="https://arxiv.org/abs/1911.11907">https://arxiv.org/abs/1911.11907</a></li>
</ul>
<h2>Dynamic Computation</h2>
<ol>
<li>同一个网络，自己来决定计算量，比如是在不同的设备上，又或者是在同设备的不同时期（比如闲时和忙时，比如电量充足和虚电时）</li>
<li>为什么不为不同的场景准备不同的model呢？<ul>
<li>反而需要更大的存储空间，与问题起源（资源瓶颈）冲突了。</li>
</ul>
</li>
</ol>
<h3>Dynamic Depth</h3>
<p>在部分layer之后，每一层都插一个额外的layer，提前做预测和输出，由调用者根据具体情况决定需要多深的depth来产生输出。</p><p>训练的时候既要考虑网络终点的loss，还要考虑所有提前结束的layer的softmax结果，加到一起算个大的Loss</p><p>Multi-Scale Dense Network(MSDNet)</p><ul>
<li><a href="https://arxviv.org/abs/1703.09844">https://arxviv.org/abs/1703.09844</a></li>
</ul>
<h3>Dynamic Width</h3>
<p>训练的时候（同时？）对不同宽度（即神经元个数，或filter个数）进行计算（全部深度），也是把每种宽度最后产生的loss加起来当作总的Loss</p><p>在保留的宽度里，参数是一样的（所以应该就是同一轮训练里的参数了）</p><p>Slimmable Neural Networks</p><ul>
<li><a href="https://arxiv.org/abs/1812.08928">https://arxiv.org/abs/1812.08928</a></li>
</ul>
<h3>Computation based on Sample Difficulty</h3>
<p>上述决定采用什么样的network/model的是人工决定的，那么有没有让机器自己决定采用什么网络的呢？</p><p>比如一张简单的图片，几层或一层网张就能得到结果，而另一张可能前景和或背景更复杂的图片，需要很多层才能最终把特征提取出来，应用同一个模型的话就有点资源浪费了。</p><ul>
<li>SkipNet: Learning Dynamic Routing in Convolutional Networks</li>
<li>Runtime Neural Pruning</li>
<li>BlockDrop: Dynamic Inference Paths in Residual Networks</li>
</ul>
<h1>Meta Learning</h1>
<ul>
<li>学习的学习。</li>
<li>之前的machine learning，输出是明确的任务，比如是一个数字，还是一个分类；而meta-learning，输出是一个model/network，用这个model，可以去做machine learning的任务。</li>
<li>它就相当于一个“返函数的函数”</li>
<li>meta-learning 就是让机器学会去架构一个网络，初始化，学习率等等 $\leftarrow \varPhi$: <code>learnable components</code><ul>
<li>categorize meta learning based on what is learnable</li>
</ul>
</li>
</ul>
<blockquote>
<p>不再深入</p></blockquote>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%9D%8E%E5%AE%8F%E6%AF%85MACHINE-LEARNING-2021-SPRING%E7%AC%94%E8%AE%B0-4/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%9D%8E%E5%AE%8F%E6%AF%85MACHINE-LEARNING-2021-SPRING%E7%AC%94%E8%AE%B0-3/" target="_self">李宏毅MACHINE LEARNING 2021 SPRING笔记[3]</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%9D%8E%E5%AE%8F%E6%AF%85MACHINE-LEARNING-2021-SPRING%E7%AC%94%E8%AE%B0-3/" target="_self">
                <time class="text-uppercase">
                    October 14 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>CNN</h1>
<ol>
<li><strong>Receptive field</strong></li>
</ol>
<p>不管是计算机，还是人脑，去认一个物，都是去判断特定的patten（所以就会有错认的图片产生），这也说明，如果神经网络要去辨识物体，是不需要每个神经元都把整张图片看一次的，只需要关注一些特征区域就好了。（感受野, <code>Receptive field</code>)</p><p>如果你一直用3x3，会不会看不到大的patten呢？$\rightarrow$ 会也不会。</p><p>首先，小的filter当然是不可能看到它的感受野以外的部分，但是，神经网络是多层架构，你这层的输出再被卷一次，这时候每一个数字代表的就是之前的9个像素计算的结果，这一轮的9个数字就是上一层的81个像素（因为stride的原因，大部分是重复的）的计算结果，换言之，感受野大大增强了，也就是说，你只需要增加层数，就可以在小的filter上得到大的patten.</p><ol start="2">
<li><strong>filter &amp; feature map</strong></li>
</ol>
<p>从神经元角度和全连接角度出发的话，每个框其实可以有自己的参数的（即你用了64步把整个图片扫描完的话，就有64组参数），而事实上为了简化模型，可以让某些框对应同样的参数（<strong>参数共享</strong>），原因就是同一特征可能出现在多个位置，比如人有两只脚。</p><p>再然后，实际上每一次都是用一组参数扫完全图的，意思是在每个角落都只搜索这<strong>一个特征</strong>。</p><p>我们把这种机制叫<code>filter</code>，一个filter只找一种特征，乘加出来的结果叫<code>feature map</code>，即这个filter提取出来的特征图。</p><p>因此，</p><ul>
<li>你想提取多少个特征，就得有多少个filter</li>
<li>表现出来就成了你这一层输出有多少个channel</li>
<li>这就是为什么你的图片进来是3channel，出来就是N个channel了，取决于你设计了多少个filter</li>
</ul>
<ol start="3">
<li><strong>Pooling &amp; subsampling</strong></li>
</ol>
<p>由于图像的视觉特征，你把它放大或缩小都能被人眼认出来，因此就产生了pooling这种机制，可以降低样本的大小，这主要是为了减小运算量吧（硬件性能足够就可以不考虑它）。</p><ol start="4">
<li><strong>Data Augmentation</strong></li>
</ol>
<p>CNN并不能识别缩放、旋转、裁切、翻转过的图片，因此训练数据的增强也是必要的。</p><h2>AlphaGo</h2>
<p><strong>layer 1</strong></p><ol>
<li>能被影像化的问题就可以尝试CNN，围棋可以看成是一张19x19的图片</li>
<li>每一个位置被总结出了48种可能的情况(超参1)</li>
<li>所以输入就是19x19x48</li>
<li>用0来padding成23x23</li>
<li>很多patten、定式也是影像化的，可以被filter扫出来</li>
<li>总结出5x5大小的filter就够用了（超参2）</li>
<li>就用了192个fitler（即每一次output有48层channel)（超参3）</li>
<li>stride = 1</li>
<li>ReLU</li>
</ol>
<p><strong>layer 2-12</strong></p><ol>
<li>padding成 21x21</li>
<li>192个 3x3 filter with stride = 1</li>
<li>ReLU</li>
</ol>
<p><strong>layer 13</strong></p><ol>
<li>1x1 filter stride = 1</li>
<li>bias</li>
<li>softmax</li>
</ol>
<p>其中192(个filter)这个超参对比了128，256，384等，也就是说人类并不理解它每一次都提取了什么特征。</p><blockquote>
<p>subsampling对围棋也有用吗？ 上面的结构看出并没有用，事实上，围棋你抽掉一行一列影响是很大的。</p></blockquote>
<h1>Self-Attention</h1>
<p>前面说的都是输入为一个向量（总会拉平成一维向量），如果是多个向量呢？有这样的场景吗？</p><ul>
<li>一段文字，每一个文字都用one-hot或word-embedding来表示<ul>
<li>不但是多个向量，而且还长短不齐</li>
</ul>
</li>
<li>一段语音，每25ms采样形成一个向量，步长为每10ms重复采样，形成向量序列<ul>
<li>400 sample points (16khz)</li>
<li>39-dim MFCC</li>
<li>80-dim filter bank output</li>
<li>参考人类语言处理课程</li>
</ul>
</li>
<li>一个Graph组向量（比如social network)<ul>
<li>每个节点（每个人的profile）就是一个向量</li>
</ul>
</li>
<li>一个分子结构<ul>
<li>每个原子就是一个one-hot</li>
</ul>
</li>
</ul>
<p><strong>输出是什么样的？</strong></p><ol>
<li>一个向量对应一个输出<ul>
<li>文字 -&gt; POS tagging</li>
<li>语音 -&gt; a, a, b, b(怎么去重也参考<a href="https://speech.ee.ntu.edu.tw/~hylee/dlhlp/2020-spring.html">人类语言处理</a>课程)</li>
<li>graph -&gt; 每个节点输出特性（比如每个人的购买决策）</li>
</ul>
</li>
<li>只有一个输出<ul>
<li>文字 -&gt; 情绪分析，舆情分析</li>
<li>语音 -&gt; 判断是谁说的</li>
<li>graph -&gt; 输出整个graph的特性，比如亲水性如何</li>
</ul>
</li>
<li>不定输出（由network自己决定）<ul>
<li>这就叫seq2seq</li>
<li>文字 -&gt; 翻译</li>
<li>语音 -&gt; 真正的语音识别</li>
</ul>
</li>
</ol>
<p>self-attention</p><p>稍稍回顾一下self attention里最重要的q, k, v的部分：</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/97e9b2e0e7ac0f115036ca6bd0c71849.png" alt=""/></figure><p>图示的是q2与所有的k相乘，再分别与对应的v相乘，然后相加，得到q2对应的输出：b2的过程。</p><p>下图则是矩阵化后的结论：
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/429312b4d209231715578ba2ba3a80dc.png" alt=""/></figure>
具体细节看专题</p><p>真正要学的，就是图中的$W^q, W^k, W^v$</p><h2>Multi-head Self-attention</h2>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4ac2f963c12f8046cf93824b2a2c5f9f.png" alt=""/></figure><p>CNN是Self-attention的特例</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/9c914c0fa757448a64dfa2c88ae110e5.png" alt=""/></figure><h2>Self-attention for Graph</h2>
<p>了解更多：<a href="https://youtu.be/eybCCtNKwzA">https://youtu.be/eybCCtNKwzA</a></p><h1>Transformer</h1>
<p>Transformer是一个seq2seq的model</p><p>以下场景，不管看上去像不像是seq2seq的特征，都可以尝试用seq2seq（trnasformer）来“硬train一发”</p><ul>
<li>QA类的问题，送进去question + context，输出answer<ul>
<li>翻译，摘要，差别，情感分析，只要训练能套上上面的格式，就有可能</li>
</ul>
</li>
<li>文法剖析，送入是句子，输出是树状的语法结构<ul>
<li>把树状结构摊平（其实就是多层括号）</li>
<li>然后就用这个对应关系来当成翻译来训练（即把语法当成翻译）</li>
</ul>
</li>
<li>multi-label classification<ul>
<li>你不能在做multi-class classification的时候取top-k,因为有的属于一个类，有的属于三个类，k不定</li>
<li>所以你把每个输入和N个输出也丢到seq2seq里去硬train一发，网络会自己学到每个文章属于哪“些”类别（不定个数，也像翻译一样）</li>
</ul>
</li>
<li>object dectection<ul>
<li>这个更匪夷所思，感兴趣看论文：<a href="https://arxiv.org/abs/2005.12872(End-to-End">https://arxiv.org/abs/2005.12872(End-to-End</a> Object Detection with Transformers)</li>
</ul>
</li>
</ul>
<h2>Encoder</h2>
<p>Q, K, V(relavant/similarity), zero padding mask, layer normalization, residual等, 具体看<code>self-attention</code>一节。</p><h2>Decoder</h2>
<h3>AT v.s. NAT</h3>
<p>我们之前用的decoder都是一个一个字地预测（输出的）</p><ul>
<li>所以才有position-mask（用来屏蔽当前位置后面的字）</li>
</ul>
<p>这种叫<code>Auto Regressive</code>，简称<code>AT</code>,<code>NAT</code>即<code>Non Auto Regressive</code></p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a4e144ed0e5f9ad95a029f3224fc46e3.png" alt=""/></figure><p>它一次生成输出的句子。</p><p>至于seq2seq的输出是不定长的，它是怎么在一次输出里面确定长度的，上图已经给出了几种做法：</p><ol>
<li>另做一个predictor来输出一个数字，表示应该输出的长度</li>
<li>直接用一个足够长的<bos>做输入（比如300个），那输出也就有300个，取到第一个<eos>为止</li>
</ol>
<p>因为不是一个一个生成了，好处</p><ol>
<li>可以平行运算。</li>
<li>输出的长度更可控</li>
</ol>
<blockquote>
<p>NAT通常表现不如AT好 (why? <strong>Multi-mmodality</strong>)</p></blockquote>
<p>detail: <a href="https://youtu.be/jvyKmU4OM3c">https://youtu.be/jvyKmU4OM3c</a> (Non-Autoregressive Sequence Generation)</p><h3>AT</h3>
<p>在decoder里最初有让人看不懂的三个箭头从encode的输出里指出来:</p><figure class="vertical-figure" style="flex: 41.08681245858184" ><img width="1240" height="1509" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/04bb017a6b7821b1f8e1f676a4e89c13.png" alt=""/></figure><p>其实这就是<code>cross attention</code></p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/943872fa064ed57098cf57694c851ace.png" alt=""/></figure><p>它就是把自己第一层(self-attention后)的输出乘一个$W^q$得到的<code>q</code>，去跟encoder的输出分别乘$W^k, W^v$得到的k和v运算($\sum q \times k \times v$)得到当前位置的输出的过程。</p><p>而且研究者也尝试过各种<code>cross attention</code>的方法，而不仅仅是本文中的无论哪一层都用<code>encoder</code>最后一层的输出做q和v这一种方案：</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/d1a0d2db75519d1eb4cd58bc9a0c65a5.png" alt=""/></figure><h2>Training Tips</h2>
<h3>复制机制</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/637e1eace14b2504906690435792aa40.png" alt=""/></figure><p>一些场景，训练的时候没必要去“生成”阅读材料里提到的一些概念，只需要把它“复制”出来即可，比如上述的人名，专有名字，概念等，以及对文章做摘要等。</p><ul>
<li>Pointer Network: <a href="https://youtu.be/VdOyqNQ9aww">https://youtu.be/VdOyqNQ9aww</a></li>
<li>Copying Mechanism in Seq2Seq <a href="https://arxiv.org/abs/1603.06393">https://arxiv.org/abs/1603.06393</a></li>
</ul>
<h3>Guided Attention</h3>
<p>像语音这种连续性的，需要强制指定(guide)它的attention顺序，相对而言，文字跳跃感可以更大，语音一旦不连续就失去了可听性了，一些关键字：</p><ul>
<li>Monotonic Attention</li>
<li>Location-aware attention</li>
</ul>
<h3>Beam Search</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/0068ee933dbbe3ab1f2fdc59431bc72b.png" alt=""/></figure><h3>Optimizing Evaluation Metrics / BLEU</h3>
<ul>
<li><p>训练的时候loss用的是cross entropy，要求loss越小越好，</p></li>
<li><p>而在evaluation的时候，我们用的是预测值与真值的<code>BLEU score</code>，要求score越大越好</p></li>
<li><p>那么越小的cross entropy loss真的能产生越高的BLEU score吗？ 未必</p></li>
<li><p>那么能不能在训练的时候也用BLEU score呢？ 不行，它太复杂没法微分，就没法bp做梯度了。</p></li>
</ul>
<h3>Exposure bias</h3>
<p>训练时候应用了<code>Teaching force</code>，用了全部或部分真值当作预测结果来训练（或防止一错到底），而eval的时候确实就是一错到底的模式了。</p><h1>Self-supervised Learning</h1>
<ul>
<li>芝麻街家庭：elmo, bert, erine...</li>
<li>bert就是transformer的encoder</li>
</ul>
<h2>Bert</h2>
<h3>GLUE</h3>
<p>GLUE: General Language Understanding Evaluation</p><p>基本上就是看以下这九个模型的得分：</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/bc43a4b9f8009e33413a2f5917c37fa2.png" alt=""/></figure><p>训练：</p><ol>
<li>预测mask掉的词(masked token prediction)<ul>
<li>为训练数据集添加部分掩码，预测可能的输出</li>
<li>类似word2vec的C-Bow</li>
</ul>
</li>
<li>预测下一个句子（分类，比如是否相关）(next sentence prediction)<ul>
<li>在句首添加<cls>用来接分类结果</li>
<li>用<sep>来表示句子分隔</li>
</ul>
</li>
</ol>
<p>下游任务（Downstream Task） &lt;- Fine Tune:</p><ol>
<li>sequence -&gt; class: sentiment analysis<ul>
<li>这是需要有label的</li>
<li><cls>节点对的linear部分是随机初始化</li>
<li>bert部分是pre-train的</li>
</ul>
</li>
<li>sequence -&gt; sequence(等长): POS tagging</li>
<li>2 sequences -&gt; class: NLI(从句子A能否推出句子B)(Natural Language Inferencee)<ul>
<li>也比如文章下面的留言的立场分析</li>
<li>用<cls>输出分类结果，用<sep>分隔句子</li>
</ul>
</li>
<li>Extraction-based Question Answering: 基于已有文本的问答系统<ul>
<li>答案一定是出现在文章里面的</li>
<li>输入文章和问题的向量</li>
<li>输出两个数字(start, end)，表示答案在文章中的索引</li>
</ul>
</li>
</ol>
<p>QA输出：</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/af1aa0bae691c8837e101c1a4d97c30f.png" alt=""/></figure><p>思路：</p><ol>
<li>用<cls>input<sep>document 的格式把输入摆好</li>
<li>用pre-trained的bert模型输出同样个数的向量</li>
<li>准备两个与bert模型等长的向量（比如768维）a, b（random initialized)</li>
<li>a与document的每个向量相乘(inner product)</li>
<li>softmax后，找到最大值，对应的位置(argmax)即为start index</li>
<li>同样的事b再做一遍，得到end index</li>
</ol>
<figure  style="flex: 131.07822410147992" ><img width="1240" height="473" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5fb69b6f706227e3cc81eaa740c28606.png" alt=""/></figure><h3>Bert train seq2seq</h3>
<p>也是可能的。就是你把输入“弄坏”，比如去掉一些字词，打乱词序，倒转，替换等任意方式，让一个decoder把它还原。 -&gt; <strong>BART</strong></p><h3>附加知识</h3>
<p>有研究人员用bert去分类DNA，蛋白质，音乐。以DNA为例，元素为A,C,G,T,分别对应4个随机词汇，再用bert去分类（用一个英文的pre-trained model），同样的例子用在了蛋白质和音乐上，居然发现效果全部要好于“纯随机”。</p><p>如果之前的实验说明了bert看懂了我们的文章，那么这个荒诞的实验（用完全无关的随意的英文单词代替另一学科里面的类别）似乎证明了事情没有那么简单。</p><h3>More</h3>
<ol>
<li><a href="https://youtu.be/1_gRK9EIQpc">https://youtu.be/1_gRK9EIQpc</a></li>
<li><a href="https://youtu.be/Bywo7m6ySlk">https://youtu.be/Bywo7m6ySlk</a></li>
</ol>
<h2>Multi-lingual Bert</h2>
<p>略</p><h2>GPT-3</h2>
<p>训练是predict next token...so it can do generation(能做生成)</p><blockquote>
<p>Language Model 都能做generation</p></blockquote>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a4687a3585d0e42cada14edb4d3d0890.png" alt=""/></figure><p><a href="https://youtu.be/DOG1L9lvsDY">https://youtu.be/DOG1L9lvsDY</a></p><p>别的模型是pre-train后，再fine-tune， GPT-3是想实现zero-shot，</p><h3>Image</h3>
<p><strong>SimCLR</strong></p><ul>
<li><a href="https://arxiv.org/abs/2002.05709">https://arxiv.org/abs/2002.05709</a></li>
<li><a href="https://github.com/google-research/simclr">https://github.com/google-research/simclr</a></li>
</ul>
<p><strong>BYOL</strong></p><ul>
<li><strong>B</strong>ootstrap <strong>y</strong>our <strong>o</strong>own <strong>l</strong>atent</li>
<li><a href="https://arxiv.org/abs/2006.07733">https://arxiv.org/abs/2006.07733</a></li>
</ul>
<h3>Speech</h3>
<p>在bert上有九个任务(GLUE)来差别效果好不好，在speech领域还缺乏这样的数据库。</p><h2>Auto Encoder</h2>
<p>也是一种<code>self-supervised</code> Learning Framework -&gt; 也叫 pre-train, 回顾：
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/6d2689336625e12011479fa23633aa94.png" alt=""/></figure></p><p>在这个之前，其实有个更古老的任务，它就是<code>Auto Encoder</code></p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/b5667c49d1673c62d5fdbb794fd32053.png" alt=""/></figure><ul>
<li>用图像为例，通过一个网络encode成一个向量后，再通过一个网络解码(reconstrucion)回这张图像（哪怕有信息缺失）</li>
<li>中间生成的那个向量可以理解为对原图进行的压缩</li>
<li>或者说一种降维</li>
</ul>
<p>降维的课程：</p><ul>
<li>PCA: <a href="https://youtu.be/iwh5o_M4BNU">https://youtu.be/iwh5o_M4BNU</a></li>
<li>t-SNE: <a href="https://youtu.be/GBUEjkpoxXc">https://youtu.be/GBUEjkpoxXc</a></li>
</ul>
<p>有一个de-noising的Auto-encoder, 给入的是加了噪音的数据，经过encode-decode之后还原的是没有加噪音的数据</p><p>这就像加了噪音去训练bert</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/db0ed507503f41304ead7808d285a7f8.png" alt=""/></figure><h3>Feature Disentangle</h3>
<p>去解释auto-encoder压成的向量就叫<code>Feature Disentagle</code>，比如一段音频，哪些是内容，哪些是人物；一段文字，哪些表示语义，哪些是语法；一张图片，哪些表示物体，哪些表示纹理，等。</p><p>应用： voice conversion -&gt; 变声器</p><p>传统的做法应该是每一个语句，都有两种语音的资料，N种语言/语音的话，就需要N份。有Feature Disentangle的话，只要有两种语音的encoder，就能知道哪些是语音特征，哪些是内容特征，拼起来，就能用A的语音去读B的内容。所以<strong>前提</strong>就是能分析压缩出来的向量。</p><h3>Discrete Latent Representation</h3>
<p>如果压缩成的向量不是实数，而是一个binary或one-hot</p><ul>
<li>binary: 每一个维度几乎都有它的含义，我们只需要看它是0还是1</li>
<li>one-hot: 直接变分类了。-&gt; <code>unsupervised classification</code></li>
</ul>
<p><strong>VQVAE</strong></p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/7d4061daabfdfcf415de004a69a1636b.png" alt=""/></figure><ul>
<li>Vector Quantized Variational Auot-encoder <a href="https://arxiv.org/abs/1711.00937">https://arxiv.org/abs/1711.00937</a></li>
</ul>
<h3>Text as Representation</h3>
<ul>
<li><a href="https://arxiv.org/abs/1810.02851">https://arxiv.org/abs/1810.02851</a></li>
</ul>
<p>如果压缩成的不是一个向量，而也是一段<code>word sequence</code>，那么是不是就成了<code>summary</code>的任务？ 只要encoder和decoder都是seq2seq的model</p><p>-&gt; seq2seq2seq auto-encoder -&gt; <code>unsupervised summarization</code></p><p>事实上训练的时候encoder和decoder可能产生强关联，这个时候就引入一个额外的<code>discriminator</code>来作判别:
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e470d48770f1cee066eca5b76e49e983.png" alt=""/></figure></p><p>有点像cycle GAN，一个generator接一个discriminator，再接另一个generator</p><h3>abnormal detection</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/d8a6da742b367ace4528d833cb8623fa.png" alt=""/></figure><ul>
<li>Part 1: <a href="https://youtu.be/gDp2LXGnVLQ">https://youtu.be/gDp2LXGnVLQ</a></li>
<li>Part 2: <a href="https://youtu.be/cYrNjLxkoXs">https://youtu.be/cYrNjLxkoXs</a></li>
<li>Part 3: <a href="https://youtu.be/ueDlm2FkCnw">https://youtu.be/ueDlm2FkCnw</a></li>
<li>Part 4: <a href="https://youtu.be/XwkHOUPbc0Q">https://youtu.be/XwkHOUPbc0Q</a></li>
<li>Part 5: <a href="https://youtu.be/Fh1xFBktRLQ">https://youtu.be/Fh1xFBktRLQ</a></li>
<li>Part 6: <a href="https://youtu.be/LmFWzmn2rFY">https://youtu.be/LmFWzmn2rFY</a></li>
<li>Part 7: <a href="https://youtu.be/6W8FqUGYyDo">https://youtu.be/6W8FqUGYyDo</a></li>
</ul>
</div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%9D%8E%E5%AE%8F%E6%AF%85MACHINE-LEARNING-2021-SPRING%E7%AC%94%E8%AE%B0-3/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
    <article class="yue prism-post-item col-md-8 offset-md-2">
        <h1 class="prism-post-title"><a class="no-link" href="/archives/%E6%9D%8E%E5%AE%8F%E6%AF%85MACHINE-LEARNING-2021-SPRING%E7%AC%94%E8%AE%B0-2/" target="_self">李宏毅MACHINE LEARNING 2021 SPRING笔记[2]</a></h1>
        <div class="prism-post-time">
            <a class="no-link" href="/archives/%E6%9D%8E%E5%AE%8F%E6%AF%85MACHINE-LEARNING-2021-SPRING%E7%AC%94%E8%AE%B0-2/" target="_self">
                <time class="text-uppercase">
                    October 13 2021
                </time>
            </a>
        </div>
        <div class="prism-content"><h1>Optimization</h1>
<p>真实世界训练样本会很大，</p><ul>
<li>我们往往不会把整个所有数据直接算一次loss，来迭代梯度，</li>
<li>而是分成很多小份(mini-batch)每一小份计算一次loss（然后迭代梯度）</li>
<li>下一个小batch认前一次迭代的结果</li>
<li>也就是说，其实这是一个不严谨的迭代，用别人数据的结果来当成本轮数据的前提<ul>
<li>最准确的当然是所有数据计算梯度和迭代。</li>
<li>一定要找补的话，可以这么认为：<ul>
<li>即使一个小batch，也是可以训练到合理的参数的</li>
<li>所以前一个batch训练出来的数据，是一定程度上合理的</li>
<li>现在换了新的数据，但保持上一轮的参数，反而可以防止<code>过拟合</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure  style="flex: 66.625" ><img width="1066" height="800" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/a5c3447aeea455b8aea110482cbcd750.png" alt=""/></figure><p>minibatch还有一个极端就是batchsize=1，即每次看完一条数据就与真值做loss，这当然是可以的，而且它非常快。但是：</p><ol>
<li>小batch虽然快，但是它非常noisy（及每一笔数据都有可能是个例，没有其它数据来抵消它的影响）</li>
<li>因为有gpu平行运算的原因，只要不是batch非常大（比如10000以上），其实mini-batch并不慢</li>
<li>如果是小样本，mini-batch反而更快，因为它一来可以平行运算，在计算gradient的时候不比小batch慢，但是它比小batch要小几个数量级的update.</li>
</ol>
<p>仍然有个但是：实验证明小的batch size会有更高的准确率。
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5ff5b42e644a35896a5ff9419e005465.png" alt=""/></figure></p><p>两个local minimal，右边那个认为是不好的，因为它只要有一点偏差，与真值就会有巨大的差异。但是没懂为什么大的batch会更容易落在右边。</p><p>这是什么问题？其实是optimization的问题，后面会用一些方法来解决。</p><h2>Sigmoid -&gt; RelU</h2>
<p>前面我们用了soft的折线来模拟折线，其实还可以叠加两个真的折线(<code>ReLU</code>)，这才是我一直说的<code>整流函数</code>的名字的由来。</p><figure  style="flex: 66.625" ><img width="1066" height="800" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/dad7e4a61c95964819eb135b85290edf.png" alt=""/></figure><p>仔细看图，c和c'在第二个转折的右边，一个是向无穷大变，一个是向无穷小变，只要找到合理的斜率，就能抵消掉两个趋势，变成一条直线。</p><p>如果要用ReLU，那么简单替换一下：</p><ul>
<li>$y = b + \sum_i {\color{ccdd00}{c_i}} sigmoid(\color{green}{b_i} + \sum_j \color{blue}{w_{ij}} x_j)$</li>
<li>$y = b + \sum_{\color{red}2i} {\color{ccdd00}{c_i}} \color{red}{max}(\color{red}0,\ \color{green}{b_i} + \sum_j \color{blue}{w_{ij}} x_j)$</li>
</ul>
<p>红色的即为改动的部分，也呼应了2个relu才构成一个sigmoid的铺垫。</p><p>把每一个a当成之前的x，我们可以继续套上新的w,b,c等，生成新的a-&gt;a'
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/fe56169175a358925eb1493eef7511a9.png" alt=""/></figure></p><figure  style="flex: 52.01793721973094" ><img width="928" height="892" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/565aa95b1ba87a098f82bb221977d8f1.png" alt=""/></figure><p>而如果再叠一层，在课程里的资料里，在训练集上loss仍然能下降（到0.1），但是在测试集里，loss反而上升了（0.44)，这意味着开始过拟合了。</p><p>这就是反向介绍神经元和神经网络。先介绍数学上的动机，组成网络后再告诉你这是什么，而不是一上来就给你扯什么是神经元什么是神经网络，再来解释每一个神经元干了什么。</p><p>而传统的神经网络课程里，sigmoid是在逻辑回归里才引入的，是为了把输出限定在1和0之间。显然这里的目的不是这样的，是为了用足够多的sigmoid或relu来逼近真实的曲线（折线）</p><h2>Framework of ML</h2>
<h3>通用步骤：</h3>
<ol>
<li>设定一个函数来描述问题$y = f_\theta(x)$, 其中$\theta$就是所有未知数（参数）</li>
<li>设定一个损失函数$L(\theta)$</li>
<li>求让损失函数尽可能小的$\theta^* = arg\ \underset{\theta}{\rm min}L(\theta)$</li>
</ol>
<h3>拟合不了的原因：</h3>
<ol>
<li>过大的loss通常“暗示”了模型不合适（<strong>model bias</strong>），比如上面的用前1天数据预测后一天，可以尝试改成前7天，前30天等。<ul>
<li>大海里捞针，针其实不在海里</li>
</ul>
</li>
<li>优化问题，梯度下降不到目标值<ul>
<li>针在大海里，我却没有办法把它找出来</li>
</ul>
</li>
</ol>
<h3>如何判断是loss optimization没做好？</h3>
<p>用不同模型来比较（更简单的，更浅的）
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4a4478c4160c3e330f1d7bdc4ac4b2bb.png" alt=""/></figure></p><p>上图中，为什么56层的表现还不如20层呢？是<code>overfitting</code>吗？<strong>不一定</strong>。</p><p>我们看一下在训练集里的表现，56层居然也不如20层，这合理吗？ <strong>不合理</strong></p><blockquote>
<p>但凡20层能做到的，多出的36层可以直接全部identity（即复制前一层的输出），也不可能比20层更差（神经网络总可以学到的）</p></blockquote>
<p>这时，就是你的loss optimization有问题了。</p><h3>如何解决overfitting</h3>
<ol>
<li>增加数据量<ul>
<li>增加数据量的绝对数量</li>
<li>data augmentation数据增强（比如反复随机从训练集里取，或者对图像进行旋转缩放位移和裁剪等）</li>
</ul>
</li>
<li>缩减模型弹性<ul>
<li>（低次啊，更少的参数「特征」啊）</li>
<li>更少的神经元，层数啊</li>
<li>考虑共用参数</li>
<li>early stopping</li>
<li>regularization<ul>
<li>让损失函数与每个特征系数直接挂勾，就变成了惩罚项</li>
<li>因为它的值越大，会让损失函数越大，这样可以“惩罚”过大的权重</li>
</ul>
</li>
<li>dropout<ul>
<li>随机丢弃一些计算结果</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2>Missmatch</h2>
<p>课上一个测试，预测2/26的观看人数（周五，历史数据都是观看量低），但因为公开了这个测试，引起很多人疯狂点击，结果造成了这一天的预测结果非常差。</p><p>这个不叫overfitting，而是<code>mismatch</code>，表示的是<strong>训练集和测试集的分布是不一样的</strong></p><p>mismatch的问题，再怎么增加数据也是不可能解决的。</p><h2>optimization problems</h2>
<p>到目前为止，有两个问题没有得到解决：</p><ol>
<li>loss optimization有问题怎么解决<ul>
<li>其实就是判断是不是saddle point（鞍点）</li>
</ul>
</li>
<li>mismatch怎么解决</li>
</ol>
<h3>saddle point</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/71ae2a0cf3a214a3c0660ad34a18874e.png" alt=""/></figure><p>hessian矩阵是二次微分，当一次微分为0的时候，二次微分并不一定为0。这是题眼。</p><p>对于红杠内的部分，设$\theta - \theta^T = v$，有：</p><ul>
<li>for all v: $v^T H v &gt; 0 \rightarrow \theta'$附近的$\theta$都要更大<ul>
<li>-&gt; 确实是在<code>local minima</code></li>
</ul>
</li>
<li>for all v: $v^T H v &lt; 0 \rightarrow \theta'$附近的$\theta$都要更小<ul>
<li>-&gt; 确实是在<code>local maxima</code></li>
</ul>
</li>
<li>而时大时小，说明是在<code>saddle point</code></li>
</ul>
<p>事实上我们不可能去检查<code>所有的v</code>，这里用Hessian matrix来判断：</p><ul>
<li>$\rm H$ is <code>positive definite</code> $\rightarrow$ all eigen values are positive $\rightarrow$ local minimal</li>
<li>$\rm H$ is <code>negative definite</code> $\rightarrow$ all eigen values are negative $\rightarrow$ local maximal</li>
</ul>
<p>用一个很垃圾的网络举例，输入是1，输出是1，有w1, w2两层网络参数，因为函数简单，两次微分得到的hessian矩阵还是比较简单直观的：
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/149c13520fe91f6bd35b4512d3feb892.png" alt=""/></figure></p><p>由于特征值有正有负，我们判断在些(0, 0)这个<code>critical point</code>，它是一个<code>saddle point</code>.</p><p>如果你判断出当前的参数确实卡在了鞍点，它同时也指明了<code>update direction</code>!</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/81aa9722408cf52b4a133a54a7435dd9.png" alt=""/></figure><p>图中，</p><ol>
<li>先构建出了一个小于0的结果，以便找到可以让$L(\theta)$收敛的目标</li>
<li>这个结果依赖于找到这样一个u<ul>
<li>这个u是$\theta, \theta'$相减的结果</li>
<li>它还是$H$的<code>eigen vector</code></li>
<li>它的<code>eigen value</code>$\rightarrow \lambda$ 还要小于0</li>
</ul>
</li>
</ol>
<p>实际上，<code>eigen value</code>是可以直接求出来的（上例已经求出来了），由它可以推出<code>eigen vector</code>，比如[1, 1]$^T$（自行补相关课程），往往会一对多，应该都是合理的，我们顺着共中一个u去更新$\theta$，就可以继续收敛loss。</p><blockquote>
<p>实际不会真的去计算hessian matrix?</p></blockquote>
<h3>Momentum</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/14f0976b60bb909a3ec3b147594b49bb.png" alt=""/></figure><p>不管是较为平坦的面，还是saddle point，如果小球以图示的方式滚下去，真实的物理世界是不可能停留在那个gradient为0或接近于0的位置的，因为它有“动量”，即惯性，甚至还可能滚过local minima，这恰好是我们需要的特性。
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/f2711cc9c420552051336483c760c347.png" alt=""/></figure>
不但考虑当前梯度，还考虑之前累积的值（动量），这个之前，是之前所有的动量，而不是前一步的：
$$
\begin{aligned}
m^0 &amp;= 0 \
m^1 &amp;= -\eta g^0 \
m^2 &amp;= -\lambda \eta g^0 - \eta g^1 \
&amp;\vdots
\end{aligned}
$$</p><h3>adaptive learning rate</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/632ad7d3ca2cd8bae9138dfdcd311805.png" alt=""/></figure><p>不是什么时候loss卡住了就说明到了极点(最小值，鞍点，平坦的点)</p><p>看下面这个error surface，两个参数，一个变动非常平缓，一个非常剧烈，如果应用相同的<code>learning rate</code>，要么反复横跳（过大），要么就再也挪不动步（太小）：</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/78118fcfe7c7a300c0fb3c063101642e.png" alt=""/></figure><h3>Adagrad (Root Mean Square)</h3>
<p>于是有了下面的优化方法，思路与<code>l2正则化</code>差不多，利用不同参数本身gradient的大小来“惩罚”它起到的作用。</p><ol>
<li>这里用的是相除，因为我的梯度越小，步伐就可以跨得更大了。</li>
<li>并且采用的是梯度的平方和(<code>Root Mean Square</code>)</li>
</ol>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/5cad715ddff837d3280d5f38270b27c6.png" alt=""/></figure><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e6eb54b116d3c2b0889449550c4ab5a1.png" alt=""/></figure><p>图中可以看出平缓的$\theta_1$就可以应用大的学习率，反之亦然。这个方法就是<code>Adagrad</code>的由来。不同的参数用不同的步伐来迭代，这是一种思路。</p><p>这就解决问题了吗？看下面这个新月形的error surface，不卖关子了，这个以前接触的更多，即梯度随时间的变化而不同，</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/2faed0f3097f4189d91a745c25ee50ca.png" alt=""/></figure><h3>RMSProp</h3>
<p>这个方法是找不到论文的。核心思想是在<code>Adagrad</code>做平方和的时候，给了一个$\alpha$作为当前这个梯度的权重(0,1)，而把前面产生的$\sigma$直接应用$(1-\alpha)$：</p><ul>
<li>$\theta_i^{t+1} \leftarrow \theta_i^t - \frac{\eta}{\color{red}{\sigma_i^t}} g_i^t$</li>
<li>$\sigma_i^t = \sqrt{\alpha(\theta_i^{t-1})^2 + (1-\alpha)(g_i^t)^2}$</li>
</ul>
<figure  style="flex: 118.22660098522168" ><img width="960" height="406" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/e2c29123c5ddf87908d3328295e5bb79.png" alt=""/></figure><h3>Adam: (RMSProp + Momentum)</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/399b29c70ef02dadc3f57a47ddca3a2f.png" alt=""/></figure><h3>Learning Rate Scheduling</h3>
<p>终于来到了最直观的lr scheduling部分，也是最容易理解的，随着时间的变化（如果你拟合有效的话），越接近local minima，lr越小。</p><p>而RMSProp一节里说的lr随时间变化并不是这一节里的随时间变化，而是设定一个权重，始终让<strong>当前</strong>的梯度拥有最高权重，注重的是当前与过往，而schedule则考量的是有计划的减小。</p><p>下图中，应用了adam优化后，由于长久以来横向移动累积的小梯度会突然爆发，形成了图中的局面，应用了scheduling后，人为在越靠近极值学习率越低，很明显直接就解决了这个问题。
<figure  style="flex: 50.7399577167019" ><img width="960" height="946" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/3d5a17833ffc7c40d1b452b9e7bd6771.png" alt=""/></figure></p><p>而<code>warm up</code>没有在原理或直观上讲解更多，了解一下吧，实操上是很可行的，很多知名的网络都用了它：</p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/4357f7df834313bc33800b14e2268252.png" alt=""/></figure><p>要强行解释的话，就是adam的$\theta$是一个基于统计的结果，所以要在看了足够多的数据之后才有意义，因此采用了一开始小步伐再增加到大步伐这样一个过度，拿到足够的数据之后，才开始一个正常的不断减小的schedule的过程。</p><p>更多可参考：<code>RAdam</code>: <a href="https://arxiv.org/abs/1908.03265">https://arxiv.org/abs/1908.03265</a></p><h3>Summary of Optimization</h3>
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/fd50408d5cc7b3a7fc6a1b7e8542a01d.png" alt=""/></figure><p>回顾下<code>Momentum</code>，它就是不但考虑当前的梯度，还考虑之前所有的梯度（加起来），通过数学计算，当然是能算出它的”动量“的。</p><p>那么同样是累计过往的梯度，一个在分母（$\theta$)，一个在分子（momentum)，那不是抵消了吗？</p><ol>
<li>momentum是相加，保留了方向</li>
<li>$\sigma$是平方和，只保留了大小</li>
</ol>
<h2>Batch Normalization</h2>
<p>沿着cost surface找到最低点有一个思路，就是能不能把山“铲平”？即把地貌由崎岖变得平滑点？ <code>batch normalization</code>就是其中一种把山铲平的方法。
<figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/495d3f5866aebabc0cc9e30a73ac917c.png" alt=""/></figure></p><p>其实就是人为控制了error的范围，让它在各个feature上面的“数量级”基本一致（均值0，方差1），这样产生的error surface不会出现某参数影响相当小，某些影响又相当大，而纯粹是因为input本身量级不同的原因（比如房价动以百万计，而年份是一年一年增的）</p><p>error surface可以想象成每一个特征拥有一个轴（课程用二到三维演示），BN让每条轴上的ticks拥有差不多的度量。</p><p>然后，你把它丢到深层网络里去，你的输出的分布又是不可控的，要接下一个网络的话，你的输出又成了下一个网络的输入。虽然你在输出前nomalization过了，但是可能被极大和极小的权重w又给变了了数量级不同的输出</p><p>再然后，不像第一层，输入的数据来自于训练资料，下一层的输入是要在上一层的输出进行sigmoid之后的</p><p>再然后，你去看看sigmoid函数的形状，它在大于一定值或小于一定值之后，对x的变化是非常不敏感了，这样非常容易了出现梯度消失的现象。</p><p>于是，出于以下两个原因，我们都会考虑在输出后也接一次batch normalization::</p><ol>
<li>归一化（$\mu=0, \delta=1$)</li>
<li>把输入压缩到一个（sigmoid梯度较大的）小区间内</li>
</ol>
<p>照这个思路，我们是需要在sigmoid之前进行一次BN的，而有的教材会告诉你之前之后做都没关系，那么之后去做就丧失了以上第二条的好处。</p><p><strong>副作用</strong></p><ul>
<li>以前$x_1 \rightarrow z_1 \rightarrow a_1$</li>
<li>现在$\tilde z_1$是用所有$z_i$算出来的，不再是独立的了</li>
</ul>
<p><strong>后记1</strong></p><p>最后，实际还会把$\tilde z_i$再这么处理一次：</p><ul>
<li>$\hat z_i = \gamma \odot \tilde z_i + \beta$</li>
</ul>
<p>不要担心又把量级和偏移都做回去了，会以1和0为初始值慢慢learn的。</p><p><strong>后记2</strong></p><p>推理的时候，如果batch size不够，甚至只有一条时，怎么去算$\mu, \sigma$呢？</p><p>pytorch在训练的时候会计算<code>moving average</code>of $\mu$ and $\sigma$ of the batches.(每次把当前批次的均值和历史均值来计算一个新的历史均值$\bar \mu$)</p><ul>
<li>$\bar \mu \leftarrow p \bar \mu + (1-p)\mu_t$</li>
</ul>
<p>推理的时候用$\bar \mu, \bar \sigma$。</p><p>最后，用了BN，平滑了error surface，学习率就可以设大一点了，加速收敛。</p><h1>Classification</h1>
<p>用数字来表示class，就会存在认为1跟2比较近与3比较远的可能（从数学运算来看也确实是的，毕竟神经网络就是不断地乘加和与真值减做对比），所以引入了one-hot，它的特征就是class之间无关联。</p><p>恰恰是这个特性，使得用one-hot来表示词向量的时候成了一个要克服的缺点。预测单词确实是一个分类问题，然后词与词之间却并不是无关的，恰恰是有距离远近的概念的，而把它还原回数字也解决不了问题，因为单个数字与前后的数字确实近了，但是空间上还是可以和很多数字接近的，所以向量还是必要的，于是又继续打补丁，才有了稠密矩阵embedding的诞生。</p><h2>softmax</h2>
<p>softmax的一个简单的解释就是你的真值是0和1的组合(one-hot)，但你的预测值可以是任何数，因为你需要把它normalize到(0,1)的区间。</p><p>当class只有两个时，用softmax和用sigmoid是一样的。</p><h2>loss</h2>
<p>可以继续用MeanSquare Error(MSE) $ e = \sum_i(\hat y_i - y'_i)^2$，但更常用的是：</p><h3>Cross-entropy</h3>
<p>$e = - \sum_i \hat y_i lny'_i$</p><blockquote>
<p><code>Minimizing cross-entropy</code> is equivalent to <code>maximizing likelihood</code></p></blockquote>
<figure  style="flex: 67.24511930585683" ><img width="1240" height="922" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/57db1539a499b753d283f44fd02b1476.png" alt=""/></figure><p>linear regression是想从真值与预测值的差来入手找到最合适的参数，而logistic regression是想找到一个符合真值分布的的预测分布。</p><p>在吴恩达的课程里，这个损失函数是”找出来的“：</p><figure class="vertical-figure" style="flex: 42.29195088676671" ><img width="1240" height="1466" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/962ad32822f268909e640f943fb27eaa.png" alt=""/></figure><ol>
<li>首先，$\theta x$后的值可以是任意值，所以再sigmoid一下，以下记为hx</li>
<li>hx的意思就是<code>y为1的概率</code></li>
<li>我需要一个损失函数，希望当真值是0时，预测y为1的概率的误差应该为无穷大<ul>
<li>也就是说hx=0时，损失函数的结果应该是无穷大</li>
<li>而hx=1时, 损失应该为0</li>
</ul>
</li>
<li>同理，当y为1时，hx=0时损失应该是无穷大，hx=1时损失为0</li>
<li>这时候才告诉你，log函数<strong>刚好长这样</strong>，请回看上面的两张图</li>
</ol>
<p>而别的地方是告诉你log是为了把概率连乘变成连加，方便计算。李宏毅这里干脆就直接告诉你公式长这样了。。。</p><p>这里绕两个弯就好了：</p><ol>
<li>y=1时，预测y为1的概率为1， y=0时，应预测y=1的概率为0</li>
<li>而这里是做损失函数，所以预测对了损失为0，错了损失无穷大</li>
<li>预测为1的概率就是hx，横轴也是hx</li>
</ol>
<blockquote>
<p>课程里说softmax和cross entorpy紧密到pytorch里直接就把两者结合到一起了，应用cross entropy的时候把softmax加到了你的network的最后一层（也就是说你没必要手写）。这里说的只是pytorch是这么处理的吗？</p><p>----是的</p></blockquote>
<h3>CE v.s. MSE</h3>
<p>数学证明：<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses/MLDS_2015_2/Lecture/Deep%20More%20(v2).ecm.mp4/index.html">http://speech.ee.ntu.edu.tw/~tlkagk/courses/MLDS_2015_2/Lecture/Deep%20More%20(v2).ecm.mp4/index.html</a></p><figure  style="flex: 66.66666666666667" ><img width="960" height="720" src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/archives/assets/97f9a28a6fef03ce00f321f79903a216.png" alt=""/></figure><p>单看实验结果，初始位置同为loss较大的左上角，因为CE有明显的梯度，很容易找到右下角的极值，但是MSE即使loss巨大，但是却没有梯度。因此对于逻辑回归，选择交叉熵从实验来看是合理的，数学推导请看上面的链接。</p></div>
        
        <div class="prism-action-bar">
            <div class="comment-action action-item"><a class="no-link text-uppercase" href="/archives/%E6%9D%8E%E5%AE%8F%E6%AF%85MACHINE-LEARNING-2021-SPRING%E7%AC%94%E8%AE%B0-2/#prism__comment" target="_self"><i class="fa fa-comment"></i>Comment</a></div>
        </div>
        
    </article>
    
</section>

<div class="container">
    <section id="prism__page__pagination" class="prism-pagination" class="col-md-8 offset-md-2">
        <ul>
            
            <li class="next">
                <a class="no-link" href="/page/2/" target="_self"><i class="fa fa-chevron-left" aria-hidden="true"></i>Newer</a>
            </li>
            
            
            <li class="prev">
                <a class="no-link" href="/page/4/" target="_self">Older<i class="fa fa-chevron-right" aria-hidden="true"></i></a>
            </li>
            
        </ul>
    </section>
</div>


</main>

            <footer id="prism__footer">
                <section>
                    <div>
                        <nav class="social-links">
                            <ul><li><a class="no-link" title="Twitter" href="https://twitter.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-twitter"></i></a></li><li><a class="no-link" title="GitHub" href="https://github.com/walkerwzy" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-github"></i></a></li><li><a class="no-link" title="Weibo" href="https://weibo.com/1071696872" target="_blank" rel="noopener noreferrer nofollow"><i class="gi gi-weibo"></i></a></li></ul>
                        </nav>
                    </div>

                    <section id="prism__external_links">
                        <ul>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://github.com/AlanDecode/Maverick" rel="noopener noreferrer nofollow">Maverick</a>：🏄‍ Go My Own Way.
                                <span>|</span>
                            </li>
                            
                            <li>
                                <a class="no-link" target="_blank" href="https://www.imalan.cn" rel="noopener noreferrer nofollow">Triple NULL</a>：Home page for AlanDecode.
                                <span>|</span>
                            </li>
                            
                        </ul>
                    </section>

                    <div class="copyright">
                        <p class="copyright-text">
                            <span class="brand">walker's code blog</span>
                            <span>Copyright © 2022 AlanDecode</span>
                        </p>
                        <p class="copyright-text powered-by">
                            | Powered by <a href="https://github.com/AlanDecode/Maverick" class="no-link" target="_blank" rel="noopener noreferrer nofollow">Maverick</a> | Theme <a href="https://github.com/Reedo0910/Maverick-Theme-Prism" target="_blank" class="no-link" rel="noopener noreferrer nofollow">Prism</a>
                        </p>
                    </div>
                    <div class="footer-addon">
                        
                    </div>
                </section>
                <script>
                    var site_build_date = "2019-12-06T12:00+08:00"

                </script>
                <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/prism-efa8685153.js"></script>
            </footer>
        </div>
    </div>
    </div>

    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/ExSearch/ExSearch-493cb9cd89.js"></script>

    <!--katex-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/katex.min.js"></script>
    <script>
        mathOpts = {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "\\[", right: "\\]", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false }
            ]
        };

    </script>
    <script defer src="https://cdn.jsdelivr.net/gh/wzywalker/wzywalker.github.io@main/assets/auto-render.min.js" onload="renderMathInElement(document.body, mathOpts);"></script>

    
</body>

</html>